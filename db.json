{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"0ee4c2c7177601b5286b5a6dc1ce977b1f8f1dd4","modified":1498386980154},{"_id":"source/_posts/CSS-BEM-命名规则核心概念介绍.md","hash":"3ded7c6d87a591f949f33991c333d6dd43c331f8","modified":1498386980155},{"_id":"source/_posts/在-Vue-js-中使用混合.md","hash":"02b98b65a05bb4429a3757731b5cc1af2f22f055","modified":1498387437262},{"_id":"source/_posts/类的复杂度和函数式编程.md","hash":"22a1856f2d9cf753b9c6dea24ca11c0120ab1e89","modified":1498387266250},{"_id":"source/_posts/深入剖析现代-JavaScript-应用.md","hash":"1e96c4940e7cce41e271b88d705dab064bf1ce54","modified":1498386980155},{"_id":"source/_posts/深度比较选择-Angular-还是-React.md","hash":"20cad633ab57d302bf3c7cbe7e700d7c7ee97803","modified":1498386980322},{"_id":"public/2017/06/24/在-Vue-js-中使用混合/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457449},{"_id":"public/2017/06/19/类的复杂度和函数式编程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457449},{"_id":"public/2017/06/16/深入剖析现代-JavaScript-应用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/2017/06/08/CSS-BEM-命名规则核心概念介绍/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/2017/06/07/深度比较选择-Angular-还是-React/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/archives/2017/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/tags/CSS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/tags/翻译/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457450},{"_id":"public/tags/JavaScript/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498387457451},{"_id":"public/CNAME","hash":"0ee4c2c7177601b5286b5a6dc1ce977b1f8f1dd4","modified":1498387457452}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"CSS BEM 命名规则核心概念介绍","date":"2017-06-08T09:57:28.000Z","_content":"\n_译者水平有限，原汁原味请移步：[原文链接](https://en.bem.info/methodology/key-concepts/)_\n\n# 核心概念\n- 块\n- 元素\n- 修饰符\n- BEM 实体\n- 混合\n- BEM 树\n- 块的实现\n- 块的实现技术\n- 块的重新定义\n- 重定义层级\n\n## 块  \n逻辑和功能独立的页面组件，等同于Web组件。一个块封装了行为（JavaScript），模板，样式（CSS），和其他实现技术。块是相对独立的，可被重复调用，这有助于项目开发和维护。  \n\n### 块特性\n\n#### 嵌套结构\n\n块可以嵌套在任何其他块中\n\n例如，一个`head`块可以包含一个logo`(logo)`,一个搜索表单`(search)`，和一个登录块`(auth)`。\n\n![](https://en.bem.info/kFetIbKxQdABHhUecbic45Il0Bg.png)\n\n#### 随处可放\n\n块即可以在单个页面上移动，也可以在项目内多个页面之间移动。块作为独立实体的实现方式让它可以在页面上改变位置的时候保持它原有的功能和外观。\n\n因此，块中的logo和登录表单可以互换位置，而不用修改CSS或JavaScript代码。\n\n![](https://en.bem.info/v80tUiEPgSQtyW9a7C8rxdn-5EM.png)\n![](https://en.bem.info/0bbhZyhaBhRzqBh5nLYQEnFpDTk.png)\n\n#### 重用\n\n一个界面可以包含多个同样的块\n\n![](https://en.bem.info/VBlEdksG7XkL4DLPWe4rcYb5hGo.png)\n\n## 元素\n\n块的组成部分且不能在块之外使用\n\n例如，一个菜单项没有用在菜单块之外，所以它实际就是一个元素 \n\n![](https://en.bem.info/cPrdQL4EZZdhPIrcYOayygPBSm4.png)\n\n> [块或元素，我应该用哪个？](https://en.bem.info/methodology/faq/#a-block-or-an-element-when-should-i-use-which)\n>\n> [在元素中用元素是 BEM 技术不推荐的](https://en.bem.info/methodology/faq/#why-does-bem-not-recommend-using-elements-within-elements-block__elem1__elem2)\n\n## 修饰符\n\n一个 BEM 实体是用来定义块或元素的外观和行为\n\n修饰符的使用是可选的\n\n修饰符本质上和 HTML 的属性相似。因为修饰符的使用，让之前的块看起来不一样。\n\n例如，菜单块的外观可能因使用了修饰符而发生改变。\n\n![](https://en.bem.info/WSU5nwZla7p44W2tdxiP371xx38.png)\n\n修饰符可以在运行时改变（比如，作为块上 DOM 事件的响应）或者通过其他块。\n\n例如，当用户点击登录按钮的时候，如果提供了一个错误的凭证，`visible` 修饰符将会被用在一个含有错误提示的隐藏块上。\n\n## BEM 实体\n\n块，元素和修饰符都被称作 BEM 实体。\n\n这个概念既可以用于表示一个独立的 BEM 实体，也可以用于表示块，元素和修饰符。\n\n## 混合\n\n例如，不同的多个BEM实体可以同时用于一个DOM节点上\n\n混合允许我们  \n - 合并多个 BEM 实体的行为和样式以避免出现代码重复\n - 在已有 BEM 实体上创建新的语义化的界面组件\n \n我们来考虑一下由一个块和另一个块中元素混合的情况\n\n我们假设项目中的链接通过`link`块来实现。我们需要把菜单项设计成链接。有这些方法可以实现。\n - 为菜单项创建指向链接的修饰符。通过修饰符来实现，需要复制`link`块的行为和样式代码。这就造成了代码重复。\n - 让一个混合体包含一个通用的link块和一个menu 块中的link元素。这两个 BEM实体的混合体可以让我们在不用复制代码的情况下使用link块的功能和menu块的样式。\n \n\n## BEM 树\n\n一个Web页面结构包含块，元素和修饰符。这是一个 DOM 树的抽象，描述了 BEM 实体的名字，他们的状态，顺序，嵌套和辅助数据。\n\n在现实项目中，BEM 树可以以任意支持树结构的方式展现。\n\n我们看看一个 DOM 树的例子：\n\n``` HTML\n<header class=\"header\">\n    <img class=\"logo\">\n    <form class=\"search-form\">\n        <input type=\"input\">\n        <button type=\"button\"></button>\n    </form>\n    <ul class=\"lang-switcher\">\n        <li class=\"lang-switcher__item\">\n            <a class=\"lang-switcher__link\" href=\"url\">en</a>\n        </li>\n        <li class=\"lang-switcher__item\">\n            <a class=\"lang-switcher__link\" href=\"url\">ru</a>\n        </li>\n    </ul>\n</header>\n```\n\n对应的 BEM 树看起来像：\n\n```\nheader\n    ├──logo\n    └──search-form\n        ├──input\n        └──button\n    └──lang-switcher\n        └──lang-switcher__item\n            └──lang-switcher__link\n        └──lang-switcher__item\n            └──lang-switcher__link\n```\n\nXML 和 BEMJSON 格式的 BEM 树为：\n\nXML\n\n``` XML\n<block:header>\n    <block:logo/>\n    <block:search-form>\n        <block:input/>\n        <block:button/>\n    </block:search-form>\n    <block:lang-switcher>\n        <elem:item>\n            <elem:link/>\n        </elem:item>\n        <elem:item>\n            <elem:link/>\n        </elem:item>\n    </block:lang-switcher>\n</block:header>\n```\n\nBEMJSON\n\n``` JSON\n{\n    block: 'header',\n    content : [\n        { block : 'logo' },\n        {\n            block : 'search-form',\n            content : [\n                { block : 'input' },\n                { block : 'button' }\n            ]\n        },\n        {\n            block : 'lang-switcher',\n            content : [\n                {\n                    elem : 'item',\n                    content : [\n                        { elem : 'link' }  \n                    ]\n                },\n                {\n                    elem : 'item',\n                    content : [\n                        { elem : 'link' }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n```\n\n## 块实现\n\n一些不同的技术可以决定一个 BEM 实体的以下几个方面：\n\n- 行为\n- 外观\n- 测试\n- 模板\n- 文档\n- 依赖描述\n- 辅助数据\n\n## 实现技术\n\n用来实现块的技术\n\n块可以通过一种或多种技术来实现，比如：\n- 行为 —— JavaScript，CoffeeScript\n- 外观 —— CSS,Stylus,Sass\n- 模板 —— BEMHTML,BH,Pug,HandleBars,XSL\n- 文档 —— Markdown,Wiki,XML\n\n举个例子，如果一个块的外观是由 CSS 定义的，这意味着块是用 CSS 技术来实现的。同样，一个块的文档是用 Markdown 格式写得，那么这个块就是由 Markdown 技术实现的。\n\n## 块的重定义\n\n在不同层级上，通过给一个块添加新特性来修改它的实现。\n\n## 重定义层级\n\n一系列的 BEM 实体和它们的部分实现\n\n一个块的最终实现可以分为不同的重定义层级。每个新层级继承或重写了原来的实现方式。最终的结果是在事先确定的顺序下，把不同定义层级的独立的块组装起来。\n\n![](https://en.bem.info/kqvCO2ZXeivuLHCbn2to5chFZrM.png)\n\nBEM 实体的任何实现技术都能被重新定义。\n\n例如，在一个单独的层级上有一个第三方类库链接到了项目上。这个库包含了现成的块的实现。特定项目的块保存在不同的重定义层级上。\n\n比如说，我们要修改这个库中一个块的外观。我们不需要改变库中代表这个块CSS样式的源代码。我们只需要在项目上创建额外的 CSS 规则。在构建过程中，实现结果将会合并类库中的原始规则和项目中的新规则。\n\n\n","source":"_posts/CSS-BEM-命名规则核心概念介绍.md","raw":"---\ntitle: CSS BEM 命名规则核心概念介绍\ndate: 2017-06-08 17:57:28\ntags: [CSS, 翻译]\n---\n\n_译者水平有限，原汁原味请移步：[原文链接](https://en.bem.info/methodology/key-concepts/)_\n\n# 核心概念\n- 块\n- 元素\n- 修饰符\n- BEM 实体\n- 混合\n- BEM 树\n- 块的实现\n- 块的实现技术\n- 块的重新定义\n- 重定义层级\n\n## 块  \n逻辑和功能独立的页面组件，等同于Web组件。一个块封装了行为（JavaScript），模板，样式（CSS），和其他实现技术。块是相对独立的，可被重复调用，这有助于项目开发和维护。  \n\n### 块特性\n\n#### 嵌套结构\n\n块可以嵌套在任何其他块中\n\n例如，一个`head`块可以包含一个logo`(logo)`,一个搜索表单`(search)`，和一个登录块`(auth)`。\n\n![](https://en.bem.info/kFetIbKxQdABHhUecbic45Il0Bg.png)\n\n#### 随处可放\n\n块即可以在单个页面上移动，也可以在项目内多个页面之间移动。块作为独立实体的实现方式让它可以在页面上改变位置的时候保持它原有的功能和外观。\n\n因此，块中的logo和登录表单可以互换位置，而不用修改CSS或JavaScript代码。\n\n![](https://en.bem.info/v80tUiEPgSQtyW9a7C8rxdn-5EM.png)\n![](https://en.bem.info/0bbhZyhaBhRzqBh5nLYQEnFpDTk.png)\n\n#### 重用\n\n一个界面可以包含多个同样的块\n\n![](https://en.bem.info/VBlEdksG7XkL4DLPWe4rcYb5hGo.png)\n\n## 元素\n\n块的组成部分且不能在块之外使用\n\n例如，一个菜单项没有用在菜单块之外，所以它实际就是一个元素 \n\n![](https://en.bem.info/cPrdQL4EZZdhPIrcYOayygPBSm4.png)\n\n> [块或元素，我应该用哪个？](https://en.bem.info/methodology/faq/#a-block-or-an-element-when-should-i-use-which)\n>\n> [在元素中用元素是 BEM 技术不推荐的](https://en.bem.info/methodology/faq/#why-does-bem-not-recommend-using-elements-within-elements-block__elem1__elem2)\n\n## 修饰符\n\n一个 BEM 实体是用来定义块或元素的外观和行为\n\n修饰符的使用是可选的\n\n修饰符本质上和 HTML 的属性相似。因为修饰符的使用，让之前的块看起来不一样。\n\n例如，菜单块的外观可能因使用了修饰符而发生改变。\n\n![](https://en.bem.info/WSU5nwZla7p44W2tdxiP371xx38.png)\n\n修饰符可以在运行时改变（比如，作为块上 DOM 事件的响应）或者通过其他块。\n\n例如，当用户点击登录按钮的时候，如果提供了一个错误的凭证，`visible` 修饰符将会被用在一个含有错误提示的隐藏块上。\n\n## BEM 实体\n\n块，元素和修饰符都被称作 BEM 实体。\n\n这个概念既可以用于表示一个独立的 BEM 实体，也可以用于表示块，元素和修饰符。\n\n## 混合\n\n例如，不同的多个BEM实体可以同时用于一个DOM节点上\n\n混合允许我们  \n - 合并多个 BEM 实体的行为和样式以避免出现代码重复\n - 在已有 BEM 实体上创建新的语义化的界面组件\n \n我们来考虑一下由一个块和另一个块中元素混合的情况\n\n我们假设项目中的链接通过`link`块来实现。我们需要把菜单项设计成链接。有这些方法可以实现。\n - 为菜单项创建指向链接的修饰符。通过修饰符来实现，需要复制`link`块的行为和样式代码。这就造成了代码重复。\n - 让一个混合体包含一个通用的link块和一个menu 块中的link元素。这两个 BEM实体的混合体可以让我们在不用复制代码的情况下使用link块的功能和menu块的样式。\n \n\n## BEM 树\n\n一个Web页面结构包含块，元素和修饰符。这是一个 DOM 树的抽象，描述了 BEM 实体的名字，他们的状态，顺序，嵌套和辅助数据。\n\n在现实项目中，BEM 树可以以任意支持树结构的方式展现。\n\n我们看看一个 DOM 树的例子：\n\n``` HTML\n<header class=\"header\">\n    <img class=\"logo\">\n    <form class=\"search-form\">\n        <input type=\"input\">\n        <button type=\"button\"></button>\n    </form>\n    <ul class=\"lang-switcher\">\n        <li class=\"lang-switcher__item\">\n            <a class=\"lang-switcher__link\" href=\"url\">en</a>\n        </li>\n        <li class=\"lang-switcher__item\">\n            <a class=\"lang-switcher__link\" href=\"url\">ru</a>\n        </li>\n    </ul>\n</header>\n```\n\n对应的 BEM 树看起来像：\n\n```\nheader\n    ├──logo\n    └──search-form\n        ├──input\n        └──button\n    └──lang-switcher\n        └──lang-switcher__item\n            └──lang-switcher__link\n        └──lang-switcher__item\n            └──lang-switcher__link\n```\n\nXML 和 BEMJSON 格式的 BEM 树为：\n\nXML\n\n``` XML\n<block:header>\n    <block:logo/>\n    <block:search-form>\n        <block:input/>\n        <block:button/>\n    </block:search-form>\n    <block:lang-switcher>\n        <elem:item>\n            <elem:link/>\n        </elem:item>\n        <elem:item>\n            <elem:link/>\n        </elem:item>\n    </block:lang-switcher>\n</block:header>\n```\n\nBEMJSON\n\n``` JSON\n{\n    block: 'header',\n    content : [\n        { block : 'logo' },\n        {\n            block : 'search-form',\n            content : [\n                { block : 'input' },\n                { block : 'button' }\n            ]\n        },\n        {\n            block : 'lang-switcher',\n            content : [\n                {\n                    elem : 'item',\n                    content : [\n                        { elem : 'link' }  \n                    ]\n                },\n                {\n                    elem : 'item',\n                    content : [\n                        { elem : 'link' }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n```\n\n## 块实现\n\n一些不同的技术可以决定一个 BEM 实体的以下几个方面：\n\n- 行为\n- 外观\n- 测试\n- 模板\n- 文档\n- 依赖描述\n- 辅助数据\n\n## 实现技术\n\n用来实现块的技术\n\n块可以通过一种或多种技术来实现，比如：\n- 行为 —— JavaScript，CoffeeScript\n- 外观 —— CSS,Stylus,Sass\n- 模板 —— BEMHTML,BH,Pug,HandleBars,XSL\n- 文档 —— Markdown,Wiki,XML\n\n举个例子，如果一个块的外观是由 CSS 定义的，这意味着块是用 CSS 技术来实现的。同样，一个块的文档是用 Markdown 格式写得，那么这个块就是由 Markdown 技术实现的。\n\n## 块的重定义\n\n在不同层级上，通过给一个块添加新特性来修改它的实现。\n\n## 重定义层级\n\n一系列的 BEM 实体和它们的部分实现\n\n一个块的最终实现可以分为不同的重定义层级。每个新层级继承或重写了原来的实现方式。最终的结果是在事先确定的顺序下，把不同定义层级的独立的块组装起来。\n\n![](https://en.bem.info/kqvCO2ZXeivuLHCbn2to5chFZrM.png)\n\nBEM 实体的任何实现技术都能被重新定义。\n\n例如，在一个单独的层级上有一个第三方类库链接到了项目上。这个库包含了现成的块的实现。特定项目的块保存在不同的重定义层级上。\n\n比如说，我们要修改这个库中一个块的外观。我们不需要改变库中代表这个块CSS样式的源代码。我们只需要在项目上创建额外的 CSS 规则。在构建过程中，实现结果将会合并类库中的原始规则和项目中的新规则。\n\n\n","slug":"CSS-BEM-命名规则核心概念介绍","published":1,"updated":"2017-06-25T10:36:20.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4cl7dhe000098vkn4ww8wjd","content":"<p><em>译者水平有限，原汁原味请移步：<a href=\"https://en.bem.info/methodology/key-concepts/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<h1 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h1><ul>\n<li>块</li>\n<li>元素</li>\n<li>修饰符</li>\n<li>BEM 实体</li>\n<li>混合</li>\n<li>BEM 树</li>\n<li>块的实现</li>\n<li>块的实现技术</li>\n<li>块的重新定义</li>\n<li>重定义层级</li>\n</ul>\n<h2 id=\"块\"><a href=\"#块\" class=\"headerlink\" title=\"块\"></a>块</h2><p>逻辑和功能独立的页面组件，等同于Web组件。一个块封装了行为（JavaScript），模板，样式（CSS），和其他实现技术。块是相对独立的，可被重复调用，这有助于项目开发和维护。  </p>\n<h3 id=\"块特性\"><a href=\"#块特性\" class=\"headerlink\" title=\"块特性\"></a>块特性</h3><h4 id=\"嵌套结构\"><a href=\"#嵌套结构\" class=\"headerlink\" title=\"嵌套结构\"></a>嵌套结构</h4><p>块可以嵌套在任何其他块中</p>\n<p>例如，一个<code>head</code>块可以包含一个logo<code>(logo)</code>,一个搜索表单<code>(search)</code>，和一个登录块<code>(auth)</code>。</p>\n<p><img src=\"https://en.bem.info/kFetIbKxQdABHhUecbic45Il0Bg.png\" alt=\"\"></p>\n<h4 id=\"随处可放\"><a href=\"#随处可放\" class=\"headerlink\" title=\"随处可放\"></a>随处可放</h4><p>块即可以在单个页面上移动，也可以在项目内多个页面之间移动。块作为独立实体的实现方式让它可以在页面上改变位置的时候保持它原有的功能和外观。</p>\n<p>因此，块中的logo和登录表单可以互换位置，而不用修改CSS或JavaScript代码。</p>\n<p><img src=\"https://en.bem.info/v80tUiEPgSQtyW9a7C8rxdn-5EM.png\" alt=\"\"><br><img src=\"https://en.bem.info/0bbhZyhaBhRzqBh5nLYQEnFpDTk.png\" alt=\"\"></p>\n<h4 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h4><p>一个界面可以包含多个同样的块</p>\n<p><img src=\"https://en.bem.info/VBlEdksG7XkL4DLPWe4rcYb5hGo.png\" alt=\"\"></p>\n<h2 id=\"元素\"><a href=\"#元素\" class=\"headerlink\" title=\"元素\"></a>元素</h2><p>块的组成部分且不能在块之外使用</p>\n<p>例如，一个菜单项没有用在菜单块之外，所以它实际就是一个元素 </p>\n<p><img src=\"https://en.bem.info/cPrdQL4EZZdhPIrcYOayygPBSm4.png\" alt=\"\"></p>\n<blockquote>\n<p><a href=\"https://en.bem.info/methodology/faq/#a-block-or-an-element-when-should-i-use-which\" target=\"_blank\" rel=\"external\">块或元素，我应该用哪个？</a></p>\n<p><a href=\"https://en.bem.info/methodology/faq/#why-does-bem-not-recommend-using-elements-within-elements-block__elem1__elem2\" target=\"_blank\" rel=\"external\">在元素中用元素是 BEM 技术不推荐的</a></p>\n</blockquote>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>一个 BEM 实体是用来定义块或元素的外观和行为</p>\n<p>修饰符的使用是可选的</p>\n<p>修饰符本质上和 HTML 的属性相似。因为修饰符的使用，让之前的块看起来不一样。</p>\n<p>例如，菜单块的外观可能因使用了修饰符而发生改变。</p>\n<p><img src=\"https://en.bem.info/WSU5nwZla7p44W2tdxiP371xx38.png\" alt=\"\"></p>\n<p>修饰符可以在运行时改变（比如，作为块上 DOM 事件的响应）或者通过其他块。</p>\n<p>例如，当用户点击登录按钮的时候，如果提供了一个错误的凭证，<code>visible</code> 修饰符将会被用在一个含有错误提示的隐藏块上。</p>\n<h2 id=\"BEM-实体\"><a href=\"#BEM-实体\" class=\"headerlink\" title=\"BEM 实体\"></a>BEM 实体</h2><p>块，元素和修饰符都被称作 BEM 实体。</p>\n<p>这个概念既可以用于表示一个独立的 BEM 实体，也可以用于表示块，元素和修饰符。</p>\n<h2 id=\"混合\"><a href=\"#混合\" class=\"headerlink\" title=\"混合\"></a>混合</h2><p>例如，不同的多个BEM实体可以同时用于一个DOM节点上</p>\n<p>混合允许我们  </p>\n<ul>\n<li>合并多个 BEM 实体的行为和样式以避免出现代码重复</li>\n<li>在已有 BEM 实体上创建新的语义化的界面组件</li>\n</ul>\n<p>我们来考虑一下由一个块和另一个块中元素混合的情况</p>\n<p>我们假设项目中的链接通过<code>link</code>块来实现。我们需要把菜单项设计成链接。有这些方法可以实现。</p>\n<ul>\n<li>为菜单项创建指向链接的修饰符。通过修饰符来实现，需要复制<code>link</code>块的行为和样式代码。这就造成了代码重复。</li>\n<li>让一个混合体包含一个通用的link块和一个menu 块中的link元素。这两个 BEM实体的混合体可以让我们在不用复制代码的情况下使用link块的功能和menu块的样式。</li>\n</ul>\n<h2 id=\"BEM-树\"><a href=\"#BEM-树\" class=\"headerlink\" title=\"BEM 树\"></a>BEM 树</h2><p>一个Web页面结构包含块，元素和修饰符。这是一个 DOM 树的抽象，描述了 BEM 实体的名字，他们的状态，顺序，嵌套和辅助数据。</p>\n<p>在现实项目中，BEM 树可以以任意支持树结构的方式展现。</p>\n<p>我们看看一个 DOM 树的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"logo\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">class</span>=<span class=\"string\">\"search-form\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"input\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__item\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__link\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"url\"</span>&gt;</span>en<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__item\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__link\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"url\"</span>&gt;</span>ru<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>对应的 BEM 树看起来像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">header</div><div class=\"line\">    ├──logo</div><div class=\"line\">    └──search-form</div><div class=\"line\">        ├──input</div><div class=\"line\">        └──button</div><div class=\"line\">    └──lang-switcher</div><div class=\"line\">        └──lang-switcher__item</div><div class=\"line\">            └──lang-switcher__link</div><div class=\"line\">        └──lang-switcher__item</div><div class=\"line\">            └──lang-switcher__link</div></pre></td></tr></table></figure>\n<p>XML 和 BEMJSON 格式的 BEM 树为：</p>\n<p>XML</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">block:header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">block:logo</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">block:search-form</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">block:input</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">block:button</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">block:search-form</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">block:lang-switcher</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">elem:link</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">elem:link</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">block:lang-switcher</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">block:header</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>BEMJSON</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    block: 'header',</div><div class=\"line\">    content : [</div><div class=\"line\">        &#123; block : 'logo' &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            block : 'search-form',</div><div class=\"line\">            content : [</div><div class=\"line\">                &#123; block : 'input' &#125;,</div><div class=\"line\">                &#123; block : 'button' &#125;</div><div class=\"line\">            ]</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            block : 'lang-switcher',</div><div class=\"line\">            content : [</div><div class=\"line\">                &#123;</div><div class=\"line\">                    elem : 'item',</div><div class=\"line\">                    content : [</div><div class=\"line\">                        &#123; elem : 'link' &#125;  </div><div class=\"line\">                    ]</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &#123;</div><div class=\"line\">                    elem : 'item',</div><div class=\"line\">                    content : [</div><div class=\"line\">                        &#123; elem : 'link' &#125;</div><div class=\"line\">                    ]</div><div class=\"line\">                &#125;</div><div class=\"line\">            ]</div><div class=\"line\">        &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"块实现\"><a href=\"#块实现\" class=\"headerlink\" title=\"块实现\"></a>块实现</h2><p>一些不同的技术可以决定一个 BEM 实体的以下几个方面：</p>\n<ul>\n<li>行为</li>\n<li>外观</li>\n<li>测试</li>\n<li>模板</li>\n<li>文档</li>\n<li>依赖描述</li>\n<li>辅助数据</li>\n</ul>\n<h2 id=\"实现技术\"><a href=\"#实现技术\" class=\"headerlink\" title=\"实现技术\"></a>实现技术</h2><p>用来实现块的技术</p>\n<p>块可以通过一种或多种技术来实现，比如：</p>\n<ul>\n<li>行为 —— JavaScript，CoffeeScript</li>\n<li>外观 —— CSS,Stylus,Sass</li>\n<li>模板 —— BEMHTML,BH,Pug,HandleBars,XSL</li>\n<li>文档 —— Markdown,Wiki,XML</li>\n</ul>\n<p>举个例子，如果一个块的外观是由 CSS 定义的，这意味着块是用 CSS 技术来实现的。同样，一个块的文档是用 Markdown 格式写得，那么这个块就是由 Markdown 技术实现的。</p>\n<h2 id=\"块的重定义\"><a href=\"#块的重定义\" class=\"headerlink\" title=\"块的重定义\"></a>块的重定义</h2><p>在不同层级上，通过给一个块添加新特性来修改它的实现。</p>\n<h2 id=\"重定义层级\"><a href=\"#重定义层级\" class=\"headerlink\" title=\"重定义层级\"></a>重定义层级</h2><p>一系列的 BEM 实体和它们的部分实现</p>\n<p>一个块的最终实现可以分为不同的重定义层级。每个新层级继承或重写了原来的实现方式。最终的结果是在事先确定的顺序下，把不同定义层级的独立的块组装起来。</p>\n<p><img src=\"https://en.bem.info/kqvCO2ZXeivuLHCbn2to5chFZrM.png\" alt=\"\"></p>\n<p>BEM 实体的任何实现技术都能被重新定义。</p>\n<p>例如，在一个单独的层级上有一个第三方类库链接到了项目上。这个库包含了现成的块的实现。特定项目的块保存在不同的重定义层级上。</p>\n<p>比如说，我们要修改这个库中一个块的外观。我们不需要改变库中代表这个块CSS样式的源代码。我们只需要在项目上创建额外的 CSS 规则。在构建过程中，实现结果将会合并类库中的原始规则和项目中的新规则。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>译者水平有限，原汁原味请移步：<a href=\"https://en.bem.info/methodology/key-concepts/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<h1 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h1><ul>\n<li>块</li>\n<li>元素</li>\n<li>修饰符</li>\n<li>BEM 实体</li>\n<li>混合</li>\n<li>BEM 树</li>\n<li>块的实现</li>\n<li>块的实现技术</li>\n<li>块的重新定义</li>\n<li>重定义层级</li>\n</ul>\n<h2 id=\"块\"><a href=\"#块\" class=\"headerlink\" title=\"块\"></a>块</h2><p>逻辑和功能独立的页面组件，等同于Web组件。一个块封装了行为（JavaScript），模板，样式（CSS），和其他实现技术。块是相对独立的，可被重复调用，这有助于项目开发和维护。  </p>\n<h3 id=\"块特性\"><a href=\"#块特性\" class=\"headerlink\" title=\"块特性\"></a>块特性</h3><h4 id=\"嵌套结构\"><a href=\"#嵌套结构\" class=\"headerlink\" title=\"嵌套结构\"></a>嵌套结构</h4><p>块可以嵌套在任何其他块中</p>\n<p>例如，一个<code>head</code>块可以包含一个logo<code>(logo)</code>,一个搜索表单<code>(search)</code>，和一个登录块<code>(auth)</code>。</p>\n<p><img src=\"https://en.bem.info/kFetIbKxQdABHhUecbic45Il0Bg.png\" alt=\"\"></p>\n<h4 id=\"随处可放\"><a href=\"#随处可放\" class=\"headerlink\" title=\"随处可放\"></a>随处可放</h4><p>块即可以在单个页面上移动，也可以在项目内多个页面之间移动。块作为独立实体的实现方式让它可以在页面上改变位置的时候保持它原有的功能和外观。</p>\n<p>因此，块中的logo和登录表单可以互换位置，而不用修改CSS或JavaScript代码。</p>\n<p><img src=\"https://en.bem.info/v80tUiEPgSQtyW9a7C8rxdn-5EM.png\" alt=\"\"><br><img src=\"https://en.bem.info/0bbhZyhaBhRzqBh5nLYQEnFpDTk.png\" alt=\"\"></p>\n<h4 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h4><p>一个界面可以包含多个同样的块</p>\n<p><img src=\"https://en.bem.info/VBlEdksG7XkL4DLPWe4rcYb5hGo.png\" alt=\"\"></p>\n<h2 id=\"元素\"><a href=\"#元素\" class=\"headerlink\" title=\"元素\"></a>元素</h2><p>块的组成部分且不能在块之外使用</p>\n<p>例如，一个菜单项没有用在菜单块之外，所以它实际就是一个元素 </p>\n<p><img src=\"https://en.bem.info/cPrdQL4EZZdhPIrcYOayygPBSm4.png\" alt=\"\"></p>\n<blockquote>\n<p><a href=\"https://en.bem.info/methodology/faq/#a-block-or-an-element-when-should-i-use-which\" target=\"_blank\" rel=\"external\">块或元素，我应该用哪个？</a></p>\n<p><a href=\"https://en.bem.info/methodology/faq/#why-does-bem-not-recommend-using-elements-within-elements-block__elem1__elem2\" target=\"_blank\" rel=\"external\">在元素中用元素是 BEM 技术不推荐的</a></p>\n</blockquote>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>一个 BEM 实体是用来定义块或元素的外观和行为</p>\n<p>修饰符的使用是可选的</p>\n<p>修饰符本质上和 HTML 的属性相似。因为修饰符的使用，让之前的块看起来不一样。</p>\n<p>例如，菜单块的外观可能因使用了修饰符而发生改变。</p>\n<p><img src=\"https://en.bem.info/WSU5nwZla7p44W2tdxiP371xx38.png\" alt=\"\"></p>\n<p>修饰符可以在运行时改变（比如，作为块上 DOM 事件的响应）或者通过其他块。</p>\n<p>例如，当用户点击登录按钮的时候，如果提供了一个错误的凭证，<code>visible</code> 修饰符将会被用在一个含有错误提示的隐藏块上。</p>\n<h2 id=\"BEM-实体\"><a href=\"#BEM-实体\" class=\"headerlink\" title=\"BEM 实体\"></a>BEM 实体</h2><p>块，元素和修饰符都被称作 BEM 实体。</p>\n<p>这个概念既可以用于表示一个独立的 BEM 实体，也可以用于表示块，元素和修饰符。</p>\n<h2 id=\"混合\"><a href=\"#混合\" class=\"headerlink\" title=\"混合\"></a>混合</h2><p>例如，不同的多个BEM实体可以同时用于一个DOM节点上</p>\n<p>混合允许我们  </p>\n<ul>\n<li>合并多个 BEM 实体的行为和样式以避免出现代码重复</li>\n<li>在已有 BEM 实体上创建新的语义化的界面组件</li>\n</ul>\n<p>我们来考虑一下由一个块和另一个块中元素混合的情况</p>\n<p>我们假设项目中的链接通过<code>link</code>块来实现。我们需要把菜单项设计成链接。有这些方法可以实现。</p>\n<ul>\n<li>为菜单项创建指向链接的修饰符。通过修饰符来实现，需要复制<code>link</code>块的行为和样式代码。这就造成了代码重复。</li>\n<li>让一个混合体包含一个通用的link块和一个menu 块中的link元素。这两个 BEM实体的混合体可以让我们在不用复制代码的情况下使用link块的功能和menu块的样式。</li>\n</ul>\n<h2 id=\"BEM-树\"><a href=\"#BEM-树\" class=\"headerlink\" title=\"BEM 树\"></a>BEM 树</h2><p>一个Web页面结构包含块，元素和修饰符。这是一个 DOM 树的抽象，描述了 BEM 实体的名字，他们的状态，顺序，嵌套和辅助数据。</p>\n<p>在现实项目中，BEM 树可以以任意支持树结构的方式展现。</p>\n<p>我们看看一个 DOM 树的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"logo\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">class</span>=<span class=\"string\">\"search-form\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"input\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__item\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__link\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"url\"</span>&gt;</span>en<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__item\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lang-switcher__link\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"url\"</span>&gt;</span>ru<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>对应的 BEM 树看起来像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">header</div><div class=\"line\">    ├──logo</div><div class=\"line\">    └──search-form</div><div class=\"line\">        ├──input</div><div class=\"line\">        └──button</div><div class=\"line\">    └──lang-switcher</div><div class=\"line\">        └──lang-switcher__item</div><div class=\"line\">            └──lang-switcher__link</div><div class=\"line\">        └──lang-switcher__item</div><div class=\"line\">            └──lang-switcher__link</div></pre></td></tr></table></figure>\n<p>XML 和 BEMJSON 格式的 BEM 树为：</p>\n<p>XML</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">block:header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">block:logo</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">block:search-form</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">block:input</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">block:button</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">block:search-form</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">block:lang-switcher</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">elem:link</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">elem:link</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">elem:item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">block:lang-switcher</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">block:header</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>BEMJSON</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    block: 'header',</div><div class=\"line\">    content : [</div><div class=\"line\">        &#123; block : 'logo' &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            block : 'search-form',</div><div class=\"line\">            content : [</div><div class=\"line\">                &#123; block : 'input' &#125;,</div><div class=\"line\">                &#123; block : 'button' &#125;</div><div class=\"line\">            ]</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            block : 'lang-switcher',</div><div class=\"line\">            content : [</div><div class=\"line\">                &#123;</div><div class=\"line\">                    elem : 'item',</div><div class=\"line\">                    content : [</div><div class=\"line\">                        &#123; elem : 'link' &#125;  </div><div class=\"line\">                    ]</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &#123;</div><div class=\"line\">                    elem : 'item',</div><div class=\"line\">                    content : [</div><div class=\"line\">                        &#123; elem : 'link' &#125;</div><div class=\"line\">                    ]</div><div class=\"line\">                &#125;</div><div class=\"line\">            ]</div><div class=\"line\">        &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"块实现\"><a href=\"#块实现\" class=\"headerlink\" title=\"块实现\"></a>块实现</h2><p>一些不同的技术可以决定一个 BEM 实体的以下几个方面：</p>\n<ul>\n<li>行为</li>\n<li>外观</li>\n<li>测试</li>\n<li>模板</li>\n<li>文档</li>\n<li>依赖描述</li>\n<li>辅助数据</li>\n</ul>\n<h2 id=\"实现技术\"><a href=\"#实现技术\" class=\"headerlink\" title=\"实现技术\"></a>实现技术</h2><p>用来实现块的技术</p>\n<p>块可以通过一种或多种技术来实现，比如：</p>\n<ul>\n<li>行为 —— JavaScript，CoffeeScript</li>\n<li>外观 —— CSS,Stylus,Sass</li>\n<li>模板 —— BEMHTML,BH,Pug,HandleBars,XSL</li>\n<li>文档 —— Markdown,Wiki,XML</li>\n</ul>\n<p>举个例子，如果一个块的外观是由 CSS 定义的，这意味着块是用 CSS 技术来实现的。同样，一个块的文档是用 Markdown 格式写得，那么这个块就是由 Markdown 技术实现的。</p>\n<h2 id=\"块的重定义\"><a href=\"#块的重定义\" class=\"headerlink\" title=\"块的重定义\"></a>块的重定义</h2><p>在不同层级上，通过给一个块添加新特性来修改它的实现。</p>\n<h2 id=\"重定义层级\"><a href=\"#重定义层级\" class=\"headerlink\" title=\"重定义层级\"></a>重定义层级</h2><p>一系列的 BEM 实体和它们的部分实现</p>\n<p>一个块的最终实现可以分为不同的重定义层级。每个新层级继承或重写了原来的实现方式。最终的结果是在事先确定的顺序下，把不同定义层级的独立的块组装起来。</p>\n<p><img src=\"https://en.bem.info/kqvCO2ZXeivuLHCbn2to5chFZrM.png\" alt=\"\"></p>\n<p>BEM 实体的任何实现技术都能被重新定义。</p>\n<p>例如，在一个单独的层级上有一个第三方类库链接到了项目上。这个库包含了现成的块的实现。特定项目的块保存在不同的重定义层级上。</p>\n<p>比如说，我们要修改这个库中一个块的外观。我们不需要改变库中代表这个块CSS样式的源代码。我们只需要在项目上创建额外的 CSS 规则。在构建过程中，实现结果将会合并类库中的原始规则和项目中的新规则。</p>\n"},{"title":"在 Vue.js 中使用混合","date":"2017-06-24T15:22:38.000Z","_content":"\n_译者水平有限，原汁原味请移步：[原文链接](https://css-tricks.com/using-mixins-vue-js/?utm_campaign=Revue%20newsletter&utm_medium=Newsletter&utm_source=revue/)_\n\n有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。\n\n这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快会变得混乱不堪，对维护者很不友好，甚至是你自己，为了使用它，需要理解一大段上下文，这会让你感到失望。\n\n使用混合。Vue 中的混合对编写函数式风格的代码很有用，因为函数式编程就是通过减少移动的部分让代码更好理解（引用于 [Michael Feathers](https://twitter.com/mfeathers/status/29581296216?lang=en) ）。混合允许你封装一块在应用的其他组件中都可以使用的函数。如果被正确的使用，他们不会改变函数作用域外部的任何东西，所以多次执行，只要是同样的输入你总是能得到一样的值。这真的很强大。\n\n### 基础实例\n\n我们有一对不同的组件，它们的作用是切换一个状态布尔值，一个模态框和一个提示框。这些提示框和模态框除了在功能上，没有其他共同点：它们看起来不一样，用法不一样，但是逻辑一样。\n\n```\n// 模态框\nconst Modal = {\n  template: '#modal',\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  },\n  components: {\n    appChild: Child\n  }\n}\n\n// 提示框\nconst Tooltip = {\n  template: '#tooltip',\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  },\n  components: {\n    appChild: Child\n  }\n}\n\n```\n\n我们可以提取出这个逻辑并创建可以被重用的项：\n\n```\nconst toggle = {\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  }\n}\n\nconst Modal = {\n  template: '#modal',\n  mixins: [toggle],\n  components: {\n    appChild: Child\n  }\n};\n\nconst Tooltip = {\n  template: '#tooltip',\n  mixins: [toggle],\n  components: {\n    appChild: Child\n  }\n};\n\n```\n\n查看 Sarah Drasner([@sdras](https://codepen.io/sdras)) 在[CodePen](https://codepen.io)上编写 [混合](https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/)的例子\n\n为了更容易理解混合，这个例子故意编写的简单一些。真实应用中使用混合的有，包含但不限于：获取视窗和组件的尺寸，采集特定的鼠标事件和图表的基本元素。Paul Pflugradt 有一个关于 [Vue Mixins 的优秀项目](https://github.com/paulpflug/vue-mixins)，但值得一提的是它是用 coffeescript 编写的。\n\n### 用法\n\n这个例子没有告诉我们在一个真实的应用中如何使用，所以，我们看看接下来要怎么做。\n\n你可以按照你喜欢的任意方式设置你的目录结构，但为了更好的组织结构我喜欢新建一个 `mixin` 目录。我们创建的这个文件含有`.js`扩展名（跟`.vue`相对，就像我们的其他文件），并且为了混合我们需要输出一个对象。\n\n![directory structure shows mixins in a folder in components directory](http://p0.qhimg.com/t0195da96ce6d7eb510.jpg)\n\n接着在 Modal.vue 中使用它，通过像下面这样的引入方式：\n\n```\nimport Child from './Child'\nimport { toggle } from './mixins/toggle'\n\nexport default {\n  name: 'modal',\n  mixins: [toggle],\n  components: {\n    appChild: Child\n  }\n}\n\n```\n\n即使我们使用的是一个对象而不是一个组件，生命周期函数对我们来说仍然是可用的，理解这点很重要。我们可以在这使用`mounted()`钩子函数，它将被应用于组件的生命周期上，这种工作方式真的很灵活也很强大。\n\n### 合并\n\n看最后这个例子，我们可以看到，我们不仅有自己的函数，而且来自于混合的生命周期函数对我们来说也是可用的，所以当在组件上注册重复的过程时，顺序很重要。默认混合上会首先被注册，组件上的接着注册，这样如有必要我们可以重写它。**组件拥有最终发言权**当有一个冲突并且这个组件不得不“决定”哪个胜出的时候，这真的变得很重要，否则，所有的东西都被放在一个数组当中执行，混合中的先执行，组件中的接着执行。\n\n```\n//mixin\nconst hi = {\n  mounted() {\n    console.log('hello from mixin!')\n  }\n}\n\n//vue instance or component\nnew Vue({\n  el: '#app',\n  mixins: [hi],\n  mounted() {\n    console.log('hello from Vue instance!')\n  }\n});\n\n//Output in console\n> hello from mixin!\n> hello from Vue instance!\n\n```\n\n如果这两个冲突了，我们看看 Vue实例或组件是如何取胜的：\n\n```\n//mixin\nconst hi = {\n  methods: {\n    sayHello: function() {\n      console.log('hello from mixin!')\n    }\n  },\n  mounted() {\n    this.sayHello()\n  }\n}\n\n//vue instance or component\nnew Vue({\n  el: '#app',\n  mixins: [hi],\n  methods: {\n    sayHello: function() {\n      console.log('hello from Vue instance!')\n    }\n  },\n  mounted() {\n    this.sayHello()\n  }\n})\n\n// Output in console\n> hello from Vue instance!\n> hello from Vue instance!\n\n```\n\n你可能已经注意到这有两个`console.log`而不是一个——这是因为第一个函数被调用时，没有被销毁，它被重写了。我们两次调用的都是`sayHello()`函数。\n\n\n### 全局混合\n\n当我们使用全局混合时，我们不是指能够在每个组件上访问它们，就像是过滤器一样。我们能够通过`mixins:[toggle]`访问组件上的混合对象。\n\n全局混合被注册到了_每个单一组件上_。因此，它们的使用场景极其有限并且要非常的小心。一个我能想到的用途就是它像一个插件，你需要赋予它访问所有东西的权限。但即使在这种情况下，我也对你正在做的保持警惕，尤其是你在应用中扩展的函数，可能对你来说是不可知的。\n\n为了创建一个全局实例，我们可以把它放在 Vue 实例之上。在一个典型的 Vue-cli 初始化的项目中，它可能在你的`main.js`文件中。\n\n```\nVue.mixin({\n  mounted() {\n    console.log('hello from mixin!')\n  }\n})\n\nnew Vue({\n  ...\n})\n\n```\n\n再次提醒，小心使用它！那个 `console.log`将会出现在每个组件上。这种情况还不算坏（除了控制台上有多余的输出），但如果它被错误的使用，你将能看到它会多么的有害。\n\n### 结论\n\n混合对于封装一小段想要复用的代码来讲是有用的。对你来说它们当然不是唯一可行的选择：高阶组件，例如，允许组合相似函数，这只是实现的一种方式。我喜欢混合，因为我不需要传递状态，但是这种模式当然也可能会被滥用，所以，仔细思考哪种选择对你的应用最有意义。\n                ","source":"_posts/在-Vue-js-中使用混合.md","raw":"---\ntitle: 在 Vue.js 中使用混合\ndate: 2017-06-24 23:22:38\ntags:  [JavaScript, 翻译]\n---\n\n_译者水平有限，原汁原味请移步：[原文链接](https://css-tricks.com/using-mixins-vue-js/?utm_campaign=Revue%20newsletter&utm_medium=Newsletter&utm_source=revue/)_\n\n有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。\n\n这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快会变得混乱不堪，对维护者很不友好，甚至是你自己，为了使用它，需要理解一大段上下文，这会让你感到失望。\n\n使用混合。Vue 中的混合对编写函数式风格的代码很有用，因为函数式编程就是通过减少移动的部分让代码更好理解（引用于 [Michael Feathers](https://twitter.com/mfeathers/status/29581296216?lang=en) ）。混合允许你封装一块在应用的其他组件中都可以使用的函数。如果被正确的使用，他们不会改变函数作用域外部的任何东西，所以多次执行，只要是同样的输入你总是能得到一样的值。这真的很强大。\n\n### 基础实例\n\n我们有一对不同的组件，它们的作用是切换一个状态布尔值，一个模态框和一个提示框。这些提示框和模态框除了在功能上，没有其他共同点：它们看起来不一样，用法不一样，但是逻辑一样。\n\n```\n// 模态框\nconst Modal = {\n  template: '#modal',\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  },\n  components: {\n    appChild: Child\n  }\n}\n\n// 提示框\nconst Tooltip = {\n  template: '#tooltip',\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  },\n  components: {\n    appChild: Child\n  }\n}\n\n```\n\n我们可以提取出这个逻辑并创建可以被重用的项：\n\n```\nconst toggle = {\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  }\n}\n\nconst Modal = {\n  template: '#modal',\n  mixins: [toggle],\n  components: {\n    appChild: Child\n  }\n};\n\nconst Tooltip = {\n  template: '#tooltip',\n  mixins: [toggle],\n  components: {\n    appChild: Child\n  }\n};\n\n```\n\n查看 Sarah Drasner([@sdras](https://codepen.io/sdras)) 在[CodePen](https://codepen.io)上编写 [混合](https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/)的例子\n\n为了更容易理解混合，这个例子故意编写的简单一些。真实应用中使用混合的有，包含但不限于：获取视窗和组件的尺寸，采集特定的鼠标事件和图表的基本元素。Paul Pflugradt 有一个关于 [Vue Mixins 的优秀项目](https://github.com/paulpflug/vue-mixins)，但值得一提的是它是用 coffeescript 编写的。\n\n### 用法\n\n这个例子没有告诉我们在一个真实的应用中如何使用，所以，我们看看接下来要怎么做。\n\n你可以按照你喜欢的任意方式设置你的目录结构，但为了更好的组织结构我喜欢新建一个 `mixin` 目录。我们创建的这个文件含有`.js`扩展名（跟`.vue`相对，就像我们的其他文件），并且为了混合我们需要输出一个对象。\n\n![directory structure shows mixins in a folder in components directory](http://p0.qhimg.com/t0195da96ce6d7eb510.jpg)\n\n接着在 Modal.vue 中使用它，通过像下面这样的引入方式：\n\n```\nimport Child from './Child'\nimport { toggle } from './mixins/toggle'\n\nexport default {\n  name: 'modal',\n  mixins: [toggle],\n  components: {\n    appChild: Child\n  }\n}\n\n```\n\n即使我们使用的是一个对象而不是一个组件，生命周期函数对我们来说仍然是可用的，理解这点很重要。我们可以在这使用`mounted()`钩子函数，它将被应用于组件的生命周期上，这种工作方式真的很灵活也很强大。\n\n### 合并\n\n看最后这个例子，我们可以看到，我们不仅有自己的函数，而且来自于混合的生命周期函数对我们来说也是可用的，所以当在组件上注册重复的过程时，顺序很重要。默认混合上会首先被注册，组件上的接着注册，这样如有必要我们可以重写它。**组件拥有最终发言权**当有一个冲突并且这个组件不得不“决定”哪个胜出的时候，这真的变得很重要，否则，所有的东西都被放在一个数组当中执行，混合中的先执行，组件中的接着执行。\n\n```\n//mixin\nconst hi = {\n  mounted() {\n    console.log('hello from mixin!')\n  }\n}\n\n//vue instance or component\nnew Vue({\n  el: '#app',\n  mixins: [hi],\n  mounted() {\n    console.log('hello from Vue instance!')\n  }\n});\n\n//Output in console\n> hello from mixin!\n> hello from Vue instance!\n\n```\n\n如果这两个冲突了，我们看看 Vue实例或组件是如何取胜的：\n\n```\n//mixin\nconst hi = {\n  methods: {\n    sayHello: function() {\n      console.log('hello from mixin!')\n    }\n  },\n  mounted() {\n    this.sayHello()\n  }\n}\n\n//vue instance or component\nnew Vue({\n  el: '#app',\n  mixins: [hi],\n  methods: {\n    sayHello: function() {\n      console.log('hello from Vue instance!')\n    }\n  },\n  mounted() {\n    this.sayHello()\n  }\n})\n\n// Output in console\n> hello from Vue instance!\n> hello from Vue instance!\n\n```\n\n你可能已经注意到这有两个`console.log`而不是一个——这是因为第一个函数被调用时，没有被销毁，它被重写了。我们两次调用的都是`sayHello()`函数。\n\n\n### 全局混合\n\n当我们使用全局混合时，我们不是指能够在每个组件上访问它们，就像是过滤器一样。我们能够通过`mixins:[toggle]`访问组件上的混合对象。\n\n全局混合被注册到了_每个单一组件上_。因此，它们的使用场景极其有限并且要非常的小心。一个我能想到的用途就是它像一个插件，你需要赋予它访问所有东西的权限。但即使在这种情况下，我也对你正在做的保持警惕，尤其是你在应用中扩展的函数，可能对你来说是不可知的。\n\n为了创建一个全局实例，我们可以把它放在 Vue 实例之上。在一个典型的 Vue-cli 初始化的项目中，它可能在你的`main.js`文件中。\n\n```\nVue.mixin({\n  mounted() {\n    console.log('hello from mixin!')\n  }\n})\n\nnew Vue({\n  ...\n})\n\n```\n\n再次提醒，小心使用它！那个 `console.log`将会出现在每个组件上。这种情况还不算坏（除了控制台上有多余的输出），但如果它被错误的使用，你将能看到它会多么的有害。\n\n### 结论\n\n混合对于封装一小段想要复用的代码来讲是有用的。对你来说它们当然不是唯一可行的选择：高阶组件，例如，允许组合相似函数，这只是实现的一种方式。我喜欢混合，因为我不需要传递状态，但是这种模式当然也可能会被滥用，所以，仔细思考哪种选择对你的应用最有意义。\n                ","slug":"在-Vue-js-中使用混合","published":1,"updated":"2017-06-25T10:43:57.262Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4cl7dhl000598vkyln006rg","content":"<p>_译者水平有限，原汁原味请移步：<a href=\"https://css-tricks.com/using-mixins-vue-js/?utm_campaign=Revue%20newsletter&amp;utm_medium=Newsletter&amp;utm_source=revue/\" target=\"_blank\" rel=\"external\">原文链接</a>_</p>\n<p>有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。</p>\n<p>这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快会变得混乱不堪，对维护者很不友好，甚至是你自己，为了使用它，需要理解一大段上下文，这会让你感到失望。</p>\n<p>使用混合。Vue 中的混合对编写函数式风格的代码很有用，因为函数式编程就是通过减少移动的部分让代码更好理解（引用于 <a href=\"https://twitter.com/mfeathers/status/29581296216?lang=en\" target=\"_blank\" rel=\"external\">Michael Feathers</a> ）。混合允许你封装一块在应用的其他组件中都可以使用的函数。如果被正确的使用，他们不会改变函数作用域外部的任何东西，所以多次执行，只要是同样的输入你总是能得到一样的值。这真的很强大。</p>\n<h3 id=\"基础实例\"><a href=\"#基础实例\" class=\"headerlink\" title=\"基础实例\"></a>基础实例</h3><p>我们有一对不同的组件，它们的作用是切换一个状态布尔值，一个模态框和一个提示框。这些提示框和模态框除了在功能上，没有其他共同点：它们看起来不一样，用法不一样，但是逻辑一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 模态框</div><div class=\"line\">const Modal = &#123;</div><div class=\"line\">  template: &apos;#modal&apos;,</div><div class=\"line\">  data() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">      isShowing: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    toggleShow() &#123;</div><div class=\"line\">      this.isShowing = !this.isShowing;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 提示框</div><div class=\"line\">const Tooltip = &#123;</div><div class=\"line\">  template: &apos;#tooltip&apos;,</div><div class=\"line\">  data() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">      isShowing: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    toggleShow() &#123;</div><div class=\"line\">      this.isShowing = !this.isShowing;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以提取出这个逻辑并创建可以被重用的项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">const toggle = &#123;</div><div class=\"line\">  data() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">      isShowing: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    toggleShow() &#123;</div><div class=\"line\">      this.isShowing = !this.isShowing;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const Modal = &#123;</div><div class=\"line\">  template: &apos;#modal&apos;,</div><div class=\"line\">  mixins: [toggle],</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">const Tooltip = &#123;</div><div class=\"line\">  template: &apos;#tooltip&apos;,</div><div class=\"line\">  mixins: [toggle],</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>查看 Sarah Drasner(<a href=\"https://codepen.io/sdras\" target=\"_blank\" rel=\"external\">@sdras</a>) 在<a href=\"https://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>上编写 <a href=\"https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/\" target=\"_blank\" rel=\"external\">混合</a>的例子</p>\n<p>为了更容易理解混合，这个例子故意编写的简单一些。真实应用中使用混合的有，包含但不限于：获取视窗和组件的尺寸，采集特定的鼠标事件和图表的基本元素。Paul Pflugradt 有一个关于 <a href=\"https://github.com/paulpflug/vue-mixins\" target=\"_blank\" rel=\"external\">Vue Mixins 的优秀项目</a>，但值得一提的是它是用 coffeescript 编写的。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>这个例子没有告诉我们在一个真实的应用中如何使用，所以，我们看看接下来要怎么做。</p>\n<p>你可以按照你喜欢的任意方式设置你的目录结构，但为了更好的组织结构我喜欢新建一个 <code>mixin</code> 目录。我们创建的这个文件含有<code>.js</code>扩展名（跟<code>.vue</code>相对，就像我们的其他文件），并且为了混合我们需要输出一个对象。</p>\n<p><img src=\"http://p0.qhimg.com/t0195da96ce6d7eb510.jpg\" alt=\"directory structure shows mixins in a folder in components directory\"></p>\n<p>接着在 Modal.vue 中使用它，通过像下面这样的引入方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import Child from &apos;./Child&apos;</div><div class=\"line\">import &#123; toggle &#125; from &apos;./mixins/toggle&apos;</div><div class=\"line\"></div><div class=\"line\">export default &#123;</div><div class=\"line\">  name: &apos;modal&apos;,</div><div class=\"line\">  mixins: [toggle],</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即使我们使用的是一个对象而不是一个组件，生命周期函数对我们来说仍然是可用的，理解这点很重要。我们可以在这使用<code>mounted()</code>钩子函数，它将被应用于组件的生命周期上，这种工作方式真的很灵活也很强大。</p>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>看最后这个例子，我们可以看到，我们不仅有自己的函数，而且来自于混合的生命周期函数对我们来说也是可用的，所以当在组件上注册重复的过程时，顺序很重要。默认混合上会首先被注册，组件上的接着注册，这样如有必要我们可以重写它。<strong>组件拥有最终发言权</strong>当有一个冲突并且这个组件不得不“决定”哪个胜出的时候，这真的变得很重要，否则，所有的东西都被放在一个数组当中执行，混合中的先执行，组件中的接着执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//mixin</div><div class=\"line\">const hi = &#123;</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    console.log(&apos;hello from mixin!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//vue instance or component</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  mixins: [hi],</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    console.log(&apos;hello from Vue instance!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//Output in console</div><div class=\"line\">&gt; hello from mixin!</div><div class=\"line\">&gt; hello from Vue instance!</div></pre></td></tr></table></figure>\n<p>如果这两个冲突了，我们看看 Vue实例或组件是如何取胜的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//mixin</div><div class=\"line\">const hi = &#123;</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    sayHello: function() &#123;</div><div class=\"line\">      console.log(&apos;hello from mixin!&apos;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    this.sayHello()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//vue instance or component</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  mixins: [hi],</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    sayHello: function() &#123;</div><div class=\"line\">      console.log(&apos;hello from Vue instance!&apos;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    this.sayHello()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">// Output in console</div><div class=\"line\">&gt; hello from Vue instance!</div><div class=\"line\">&gt; hello from Vue instance!</div></pre></td></tr></table></figure>\n<p>你可能已经注意到这有两个<code>console.log</code>而不是一个——这是因为第一个函数被调用时，没有被销毁，它被重写了。我们两次调用的都是<code>sayHello()</code>函数。</p>\n<h3 id=\"全局混合\"><a href=\"#全局混合\" class=\"headerlink\" title=\"全局混合\"></a>全局混合</h3><p>当我们使用全局混合时，我们不是指能够在每个组件上访问它们，就像是过滤器一样。我们能够通过<code>mixins:[toggle]</code>访问组件上的混合对象。</p>\n<p>全局混合被注册到了<em>每个单一组件上</em>。因此，它们的使用场景极其有限并且要非常的小心。一个我能想到的用途就是它像一个插件，你需要赋予它访问所有东西的权限。但即使在这种情况下，我也对你正在做的保持警惕，尤其是你在应用中扩展的函数，可能对你来说是不可知的。</p>\n<p>为了创建一个全局实例，我们可以把它放在 Vue 实例之上。在一个典型的 Vue-cli 初始化的项目中，它可能在你的<code>main.js</code>文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.mixin(&#123;</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    console.log(&apos;hello from mixin!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>再次提醒，小心使用它！那个 <code>console.log</code>将会出现在每个组件上。这种情况还不算坏（除了控制台上有多余的输出），但如果它被错误的使用，你将能看到它会多么的有害。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>混合对于封装一小段想要复用的代码来讲是有用的。对你来说它们当然不是唯一可行的选择：高阶组件，例如，允许组合相似函数，这只是实现的一种方式。我喜欢混合，因为我不需要传递状态，但是这种模式当然也可能会被滥用，所以，仔细思考哪种选择对你的应用最有意义。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>_译者水平有限，原汁原味请移步：<a href=\"https://css-tricks.com/using-mixins-vue-js/?utm_campaign=Revue%20newsletter&amp;utm_medium=Newsletter&amp;utm_source=revue/\" target=\"_blank\" rel=\"external\">原文链接</a>_</p>\n<p>有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。</p>\n<p>这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快会变得混乱不堪，对维护者很不友好，甚至是你自己，为了使用它，需要理解一大段上下文，这会让你感到失望。</p>\n<p>使用混合。Vue 中的混合对编写函数式风格的代码很有用，因为函数式编程就是通过减少移动的部分让代码更好理解（引用于 <a href=\"https://twitter.com/mfeathers/status/29581296216?lang=en\" target=\"_blank\" rel=\"external\">Michael Feathers</a> ）。混合允许你封装一块在应用的其他组件中都可以使用的函数。如果被正确的使用，他们不会改变函数作用域外部的任何东西，所以多次执行，只要是同样的输入你总是能得到一样的值。这真的很强大。</p>\n<h3 id=\"基础实例\"><a href=\"#基础实例\" class=\"headerlink\" title=\"基础实例\"></a>基础实例</h3><p>我们有一对不同的组件，它们的作用是切换一个状态布尔值，一个模态框和一个提示框。这些提示框和模态框除了在功能上，没有其他共同点：它们看起来不一样，用法不一样，但是逻辑一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 模态框</div><div class=\"line\">const Modal = &#123;</div><div class=\"line\">  template: &apos;#modal&apos;,</div><div class=\"line\">  data() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">      isShowing: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    toggleShow() &#123;</div><div class=\"line\">      this.isShowing = !this.isShowing;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 提示框</div><div class=\"line\">const Tooltip = &#123;</div><div class=\"line\">  template: &apos;#tooltip&apos;,</div><div class=\"line\">  data() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">      isShowing: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    toggleShow() &#123;</div><div class=\"line\">      this.isShowing = !this.isShowing;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以提取出这个逻辑并创建可以被重用的项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">const toggle = &#123;</div><div class=\"line\">  data() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">      isShowing: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    toggleShow() &#123;</div><div class=\"line\">      this.isShowing = !this.isShowing;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const Modal = &#123;</div><div class=\"line\">  template: &apos;#modal&apos;,</div><div class=\"line\">  mixins: [toggle],</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">const Tooltip = &#123;</div><div class=\"line\">  template: &apos;#tooltip&apos;,</div><div class=\"line\">  mixins: [toggle],</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>查看 Sarah Drasner(<a href=\"https://codepen.io/sdras\" target=\"_blank\" rel=\"external\">@sdras</a>) 在<a href=\"https://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>上编写 <a href=\"https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/\" target=\"_blank\" rel=\"external\">混合</a>的例子</p>\n<p>为了更容易理解混合，这个例子故意编写的简单一些。真实应用中使用混合的有，包含但不限于：获取视窗和组件的尺寸，采集特定的鼠标事件和图表的基本元素。Paul Pflugradt 有一个关于 <a href=\"https://github.com/paulpflug/vue-mixins\" target=\"_blank\" rel=\"external\">Vue Mixins 的优秀项目</a>，但值得一提的是它是用 coffeescript 编写的。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>这个例子没有告诉我们在一个真实的应用中如何使用，所以，我们看看接下来要怎么做。</p>\n<p>你可以按照你喜欢的任意方式设置你的目录结构，但为了更好的组织结构我喜欢新建一个 <code>mixin</code> 目录。我们创建的这个文件含有<code>.js</code>扩展名（跟<code>.vue</code>相对，就像我们的其他文件），并且为了混合我们需要输出一个对象。</p>\n<p><img src=\"http://p0.qhimg.com/t0195da96ce6d7eb510.jpg\" alt=\"directory structure shows mixins in a folder in components directory\"></p>\n<p>接着在 Modal.vue 中使用它，通过像下面这样的引入方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import Child from &apos;./Child&apos;</div><div class=\"line\">import &#123; toggle &#125; from &apos;./mixins/toggle&apos;</div><div class=\"line\"></div><div class=\"line\">export default &#123;</div><div class=\"line\">  name: &apos;modal&apos;,</div><div class=\"line\">  mixins: [toggle],</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    appChild: Child</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即使我们使用的是一个对象而不是一个组件，生命周期函数对我们来说仍然是可用的，理解这点很重要。我们可以在这使用<code>mounted()</code>钩子函数，它将被应用于组件的生命周期上，这种工作方式真的很灵活也很强大。</p>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>看最后这个例子，我们可以看到，我们不仅有自己的函数，而且来自于混合的生命周期函数对我们来说也是可用的，所以当在组件上注册重复的过程时，顺序很重要。默认混合上会首先被注册，组件上的接着注册，这样如有必要我们可以重写它。<strong>组件拥有最终发言权</strong>当有一个冲突并且这个组件不得不“决定”哪个胜出的时候，这真的变得很重要，否则，所有的东西都被放在一个数组当中执行，混合中的先执行，组件中的接着执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//mixin</div><div class=\"line\">const hi = &#123;</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    console.log(&apos;hello from mixin!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//vue instance or component</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  mixins: [hi],</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    console.log(&apos;hello from Vue instance!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//Output in console</div><div class=\"line\">&gt; hello from mixin!</div><div class=\"line\">&gt; hello from Vue instance!</div></pre></td></tr></table></figure>\n<p>如果这两个冲突了，我们看看 Vue实例或组件是如何取胜的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//mixin</div><div class=\"line\">const hi = &#123;</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    sayHello: function() &#123;</div><div class=\"line\">      console.log(&apos;hello from mixin!&apos;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    this.sayHello()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//vue instance or component</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  mixins: [hi],</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    sayHello: function() &#123;</div><div class=\"line\">      console.log(&apos;hello from Vue instance!&apos;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    this.sayHello()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">// Output in console</div><div class=\"line\">&gt; hello from Vue instance!</div><div class=\"line\">&gt; hello from Vue instance!</div></pre></td></tr></table></figure>\n<p>你可能已经注意到这有两个<code>console.log</code>而不是一个——这是因为第一个函数被调用时，没有被销毁，它被重写了。我们两次调用的都是<code>sayHello()</code>函数。</p>\n<h3 id=\"全局混合\"><a href=\"#全局混合\" class=\"headerlink\" title=\"全局混合\"></a>全局混合</h3><p>当我们使用全局混合时，我们不是指能够在每个组件上访问它们，就像是过滤器一样。我们能够通过<code>mixins:[toggle]</code>访问组件上的混合对象。</p>\n<p>全局混合被注册到了<em>每个单一组件上</em>。因此，它们的使用场景极其有限并且要非常的小心。一个我能想到的用途就是它像一个插件，你需要赋予它访问所有东西的权限。但即使在这种情况下，我也对你正在做的保持警惕，尤其是你在应用中扩展的函数，可能对你来说是不可知的。</p>\n<p>为了创建一个全局实例，我们可以把它放在 Vue 实例之上。在一个典型的 Vue-cli 初始化的项目中，它可能在你的<code>main.js</code>文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.mixin(&#123;</div><div class=\"line\">  mounted() &#123;</div><div class=\"line\">    console.log(&apos;hello from mixin!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>再次提醒，小心使用它！那个 <code>console.log</code>将会出现在每个组件上。这种情况还不算坏（除了控制台上有多余的输出），但如果它被错误的使用，你将能看到它会多么的有害。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>混合对于封装一小段想要复用的代码来讲是有用的。对你来说它们当然不是唯一可行的选择：高阶组件，例如，允许组合相似函数，这只是实现的一种方式。我喜欢混合，因为我不需要传递状态，但是这种模式当然也可能会被滥用，所以，仔细思考哪种选择对你的应用最有意义。</p>\n"},{"title":"rext","date":"2017-06-19T10:39:55.000Z","_content":"_什么时候使用类，什么时候不使用，怎么替代它，为什么替代它_\n\n![](http://p0.qhimg.com/t01ec95dba8bdafa400.jpg)\n\n_译者水平有限，原汁原味请移步：[原文链接](https://medium.com/@kentcdodds/classes-complexity-and-functional-programming-a8dd86903747/)_\n\nObligatory semi-to-not-related header image via: [https://unsplash.com/photos/sMQiL_2v4vs](https://unsplash.com/photos/sMQiL_2v4vs)\n\n当涉及到应用计划持续维护的时候，我们都希望有易维护的简单代码。我们也经常争论如何实现它。在这篇博客中，我将讨论我如何看待函数，对象和类，刚好也符合这个争论。\n\n### 一个类\n\n让我们看看一个类的例子来说明我的观点：\n\n我们通过构造函数实例化声明了一个`Person`类，它拥有一些属性和方法。如果我们从 Chrome 的控制台打印出`Person`对象，它看起来像这样：\n\n![](http://p0.qhimg.com/t016be2e1b19b3063b3.png)\n\n在**proto**上拥有方法的 Person 实例\n\n这里真正值得注意的地方是，这个`person`的大部分属性都在`prototype`上（在屏幕上以`_proto_`显示）而不是`person`实例上。这是非常重要的，因为如果我们有一万个`person`实例，他们能够在同样的方法上共享引用而不是有一万个那些方法的拷贝。\n\n现在我想关注的是想要理解这段代码，你需要需要学习多少概念并且那些概念有多么复杂。\n\n* 对象：相当基础。绝对的入门级。它们不会增加复杂度。\n\n*  函数(和[闭包](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)): 这也相当的基础。闭包的确增加了一点复杂度(并且如果你不小心，它能引发一些[问题](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156) ), 但是不学习它们，你真的无法在 JavaScript 语言走得更远些 ([这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)可以学到更多).\n\n*   一个函数或者方法的`this`关键字：JavaScript 中非常重要的概念。\n\n> 我的观点是`this`学起来比较困难并且给代码增加了不必要的复杂度\n\n### `this`关键字\n\n这里是 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) 关于`this`的介绍\n\n> JavaScript 中**函数的`this`关键字**跟其他语言有点不同。并且在[严格模式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode)和非严格模式下也有些不同。\n>\n> 大多数情况下，`this`的值取决于被调用的函数。执行过程中，不能被重新赋值，并且每次函数调用的时候它都可能不一样。ES5 提供了[` bind`方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)来绑定一个函数的`this`值而[不用在意函数调用的方式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#The_bind_method)，并且ES2015提供了[箭头函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，它的`this`的作用域是词法作用域（`this`的值就是当前函数的上下文）。\n\n也许没那么复杂，但这个隐含的关系的确比对象和闭包复杂一点。你不可能避免使用对象和闭包，但我相信大多数情况你能避免使用类和`this`\n\n这有一个因使用`this`出错的例子（故意的）：\n\n> 核心问题是因为使用`this`你的函数因为各种各样的引用变得混乱不堪。\n\n想要一个更真实的例子，你可在 React ⚛️ 中寻找。如果你已经使用了 React 一段时间，你可能已经遇到了我之前遇到的错误：\n\n当你点击一个按钮的时候，你会看到： `Uncaught TypeError: Cannot read property 'setState' of null at increment`\n\n这都是因为`this`的缘故，当我们执行`onClick`时，它没有调用我们的`increment`函数，因为`this`绑定在了我们组件的实例上。有一些方法可以修正它 ([观看免费视频教程 egghead.io video 💻 ](https://egghead.io/lessons/javascript-public-class-fields-with-react-components))。\n\n> 事实上你不得不考虑`this`增加了你的认知负荷，最好避免使用它。\n\n### 如何避免 `this`\n\n如果`this`增加了很多复杂度，我们如何在不添加更复杂代码的基础上避免它。替代面向对象的方法，我们试试函数式的方法如何？如果我们使用[纯函数](https://en.wikipedia.org/wiki/Pure_function)看起来会是这样：\n\n用这种方法，我们不会用到`this`。我们无需考虑它。最终，它也很容易理解。只是函数和对象。基本上没有状态，你只需要注意这些函数，这种感觉很棒！`person`对象只是数据，所以更容易思考：\n\n![](http://p0.qhimg.com/t01a2a827ff8e8b46d8.png)\n\n`person3` 对象只有问候和名字\n\n函数式编程的另一个优势是很容易进行单元测试。你可以简单的调用函数并断言它的输出。在这之前，你无需设定任何状态。这是一个非常方便的特性。\n\n注意，只要它“足够快”，函数式编程可以让代码更容易理解。尽管执行速度不是重点，在特定场景下你可使用特定的方式来获得更好的性能表现（例如用`===`来检查对象）。通常，**使用函数式编程的瓶颈是它让你的应用变慢**。\n\n### 成本和收益\n\n`class`的使用并不坏，它的确有它的使用场景。如果你真的有一些 [“hot” code](https://en.wikipedia.org/wiki/Hot_spot_%28computer_programming%29) 并且已经成为你应用的瓶颈，这时用`class`真的可以加快速度。但 99% 的时候，情况并非如此。我不认为`class`和`this`增加的复杂度在大部分情况下是值得的（我们甚至没有使用[原型继承](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)）。我也有需要使用`class`来获得更好的性能的时候。我只在 React 组件上使用它们，因为如果你使用状态或者生命周期方法你必须使用它们（[未来](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State)可能不会）\n\n### 结论\n\n在 JavaScript 中类（和原型）有它们的使用场景。但它们是一种优化。它们没能让你的代码更加简单，反而更加复杂。所以最好把你的关注点集中在不仅学起来简单而且也容易理解的：函数和对象上。\n\n![](http://p0.qhimg.com/t01fb9a93490708dc6e.png)\n\n[再见](https://twitter.com/kentcdodds)朋友们!\n                ","source":"_posts/类的复杂度和函数式编程.md","raw":"---\ntitle: rext\ndate: 2017-06-19 18:39:55\ntags: [JavaScript, 翻译]\n---\n_什么时候使用类，什么时候不使用，怎么替代它，为什么替代它_\n\n![](http://p0.qhimg.com/t01ec95dba8bdafa400.jpg)\n\n_译者水平有限，原汁原味请移步：[原文链接](https://medium.com/@kentcdodds/classes-complexity-and-functional-programming-a8dd86903747/)_\n\nObligatory semi-to-not-related header image via: [https://unsplash.com/photos/sMQiL_2v4vs](https://unsplash.com/photos/sMQiL_2v4vs)\n\n当涉及到应用计划持续维护的时候，我们都希望有易维护的简单代码。我们也经常争论如何实现它。在这篇博客中，我将讨论我如何看待函数，对象和类，刚好也符合这个争论。\n\n### 一个类\n\n让我们看看一个类的例子来说明我的观点：\n\n我们通过构造函数实例化声明了一个`Person`类，它拥有一些属性和方法。如果我们从 Chrome 的控制台打印出`Person`对象，它看起来像这样：\n\n![](http://p0.qhimg.com/t016be2e1b19b3063b3.png)\n\n在**proto**上拥有方法的 Person 实例\n\n这里真正值得注意的地方是，这个`person`的大部分属性都在`prototype`上（在屏幕上以`_proto_`显示）而不是`person`实例上。这是非常重要的，因为如果我们有一万个`person`实例，他们能够在同样的方法上共享引用而不是有一万个那些方法的拷贝。\n\n现在我想关注的是想要理解这段代码，你需要需要学习多少概念并且那些概念有多么复杂。\n\n* 对象：相当基础。绝对的入门级。它们不会增加复杂度。\n\n*  函数(和[闭包](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)): 这也相当的基础。闭包的确增加了一点复杂度(并且如果你不小心，它能引发一些[问题](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156) ), 但是不学习它们，你真的无法在 JavaScript 语言走得更远些 ([这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)可以学到更多).\n\n*   一个函数或者方法的`this`关键字：JavaScript 中非常重要的概念。\n\n> 我的观点是`this`学起来比较困难并且给代码增加了不必要的复杂度\n\n### `this`关键字\n\n这里是 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) 关于`this`的介绍\n\n> JavaScript 中**函数的`this`关键字**跟其他语言有点不同。并且在[严格模式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode)和非严格模式下也有些不同。\n>\n> 大多数情况下，`this`的值取决于被调用的函数。执行过程中，不能被重新赋值，并且每次函数调用的时候它都可能不一样。ES5 提供了[` bind`方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)来绑定一个函数的`this`值而[不用在意函数调用的方式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#The_bind_method)，并且ES2015提供了[箭头函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，它的`this`的作用域是词法作用域（`this`的值就是当前函数的上下文）。\n\n也许没那么复杂，但这个隐含的关系的确比对象和闭包复杂一点。你不可能避免使用对象和闭包，但我相信大多数情况你能避免使用类和`this`\n\n这有一个因使用`this`出错的例子（故意的）：\n\n> 核心问题是因为使用`this`你的函数因为各种各样的引用变得混乱不堪。\n\n想要一个更真实的例子，你可在 React ⚛️ 中寻找。如果你已经使用了 React 一段时间，你可能已经遇到了我之前遇到的错误：\n\n当你点击一个按钮的时候，你会看到： `Uncaught TypeError: Cannot read property 'setState' of null at increment`\n\n这都是因为`this`的缘故，当我们执行`onClick`时，它没有调用我们的`increment`函数，因为`this`绑定在了我们组件的实例上。有一些方法可以修正它 ([观看免费视频教程 egghead.io video 💻 ](https://egghead.io/lessons/javascript-public-class-fields-with-react-components))。\n\n> 事实上你不得不考虑`this`增加了你的认知负荷，最好避免使用它。\n\n### 如何避免 `this`\n\n如果`this`增加了很多复杂度，我们如何在不添加更复杂代码的基础上避免它。替代面向对象的方法，我们试试函数式的方法如何？如果我们使用[纯函数](https://en.wikipedia.org/wiki/Pure_function)看起来会是这样：\n\n用这种方法，我们不会用到`this`。我们无需考虑它。最终，它也很容易理解。只是函数和对象。基本上没有状态，你只需要注意这些函数，这种感觉很棒！`person`对象只是数据，所以更容易思考：\n\n![](http://p0.qhimg.com/t01a2a827ff8e8b46d8.png)\n\n`person3` 对象只有问候和名字\n\n函数式编程的另一个优势是很容易进行单元测试。你可以简单的调用函数并断言它的输出。在这之前，你无需设定任何状态。这是一个非常方便的特性。\n\n注意，只要它“足够快”，函数式编程可以让代码更容易理解。尽管执行速度不是重点，在特定场景下你可使用特定的方式来获得更好的性能表现（例如用`===`来检查对象）。通常，**使用函数式编程的瓶颈是它让你的应用变慢**。\n\n### 成本和收益\n\n`class`的使用并不坏，它的确有它的使用场景。如果你真的有一些 [“hot” code](https://en.wikipedia.org/wiki/Hot_spot_%28computer_programming%29) 并且已经成为你应用的瓶颈，这时用`class`真的可以加快速度。但 99% 的时候，情况并非如此。我不认为`class`和`this`增加的复杂度在大部分情况下是值得的（我们甚至没有使用[原型继承](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)）。我也有需要使用`class`来获得更好的性能的时候。我只在 React 组件上使用它们，因为如果你使用状态或者生命周期方法你必须使用它们（[未来](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State)可能不会）\n\n### 结论\n\n在 JavaScript 中类（和原型）有它们的使用场景。但它们是一种优化。它们没能让你的代码更加简单，反而更加复杂。所以最好把你的关注点集中在不仅学起来简单而且也容易理解的：函数和对象上。\n\n![](http://p0.qhimg.com/t01fb9a93490708dc6e.png)\n\n[再见](https://twitter.com/kentcdodds)朋友们!\n                ","slug":"类的复杂度和函数式编程","published":1,"updated":"2017-06-25T10:41:06.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4cl7dhm000698vkd3h9y2xj","content":"<p><em>什么时候使用类，什么时候不使用，怎么替代它，为什么替代它</em></p>\n<p><img src=\"http://p0.qhimg.com/t01ec95dba8bdafa400.jpg\" alt=\"\"></p>\n<p><em>译者水平有限，原汁原味请移步：<a href=\"https://medium.com/@kentcdodds/classes-complexity-and-functional-programming-a8dd86903747/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<p>Obligatory semi-to-not-related header image via: <a href=\"https://unsplash.com/photos/sMQiL_2v4vs\" target=\"_blank\" rel=\"external\">https://unsplash.com/photos/sMQiL_2v4vs</a></p>\n<p>当涉及到应用计划持续维护的时候，我们都希望有易维护的简单代码。我们也经常争论如何实现它。在这篇博客中，我将讨论我如何看待函数，对象和类，刚好也符合这个争论。</p>\n<h3 id=\"一个类\"><a href=\"#一个类\" class=\"headerlink\" title=\"一个类\"></a>一个类</h3><p>让我们看看一个类的例子来说明我的观点：</p>\n<p>我们通过构造函数实例化声明了一个<code>Person</code>类，它拥有一些属性和方法。如果我们从 Chrome 的控制台打印出<code>Person</code>对象，它看起来像这样：</p>\n<p><img src=\"http://p0.qhimg.com/t016be2e1b19b3063b3.png\" alt=\"\"></p>\n<p>在<strong>proto</strong>上拥有方法的 Person 实例</p>\n<p>这里真正值得注意的地方是，这个<code>person</code>的大部分属性都在<code>prototype</code>上（在屏幕上以<code>_proto_</code>显示）而不是<code>person</code>实例上。这是非常重要的，因为如果我们有一万个<code>person</code>实例，他们能够在同样的方法上共享引用而不是有一万个那些方法的拷贝。</p>\n<p>现在我想关注的是想要理解这段代码，你需要需要学习多少概念并且那些概念有多么复杂。</p>\n<ul>\n<li><p>对象：相当基础。绝对的入门级。它们不会增加复杂度。</p>\n</li>\n<li><p>函数(和<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"external\">闭包</a>): 这也相当的基础。闭包的确增加了一点复杂度(并且如果你不小心，它能引发一些<a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"external\">问题</a> ), 但是不学习它们，你真的无法在 JavaScript 语言走得更远些 (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"external\">这里</a>可以学到更多).</p>\n</li>\n<li><p>一个函数或者方法的<code>this</code>关键字：JavaScript 中非常重要的概念。</p>\n</li>\n</ul>\n<blockquote>\n<p>我的观点是<code>this</code>学起来比较困难并且给代码增加了不必要的复杂度</p>\n</blockquote>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a><code>this</code>关键字</h3><p>这里是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"external\">MDN</a> 关于<code>this</code>的介绍</p>\n<blockquote>\n<p>JavaScript 中<strong>函数的<code>this</code>关键字</strong>跟其他语言有点不同。并且在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode\" target=\"_blank\" rel=\"external\">严格模式</a>和非严格模式下也有些不同。</p>\n<p>大多数情况下，<code>this</code>的值取决于被调用的函数。执行过程中，不能被重新赋值，并且每次函数调用的时候它都可能不一样。ES5 提供了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"external\"><code>bind</code>方法</a>来绑定一个函数的<code>this</code>值而<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#The_bind_method\" target=\"_blank\" rel=\"external\">不用在意函数调用的方式</a>，并且ES2015提供了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"external\">箭头函数</a>，它的<code>this</code>的作用域是词法作用域（<code>this</code>的值就是当前函数的上下文）。</p>\n</blockquote>\n<p>也许没那么复杂，但这个隐含的关系的确比对象和闭包复杂一点。你不可能避免使用对象和闭包，但我相信大多数情况你能避免使用类和<code>this</code></p>\n<p>这有一个因使用<code>this</code>出错的例子（故意的）：</p>\n<blockquote>\n<p>核心问题是因为使用<code>this</code>你的函数因为各种各样的引用变得混乱不堪。</p>\n</blockquote>\n<p>想要一个更真实的例子，你可在 React ⚛️ 中寻找。如果你已经使用了 React 一段时间，你可能已经遇到了我之前遇到的错误：</p>\n<p>当你点击一个按钮的时候，你会看到： <code>Uncaught TypeError: Cannot read property &#39;setState&#39; of null at increment</code></p>\n<p>这都是因为<code>this</code>的缘故，当我们执行<code>onClick</code>时，它没有调用我们的<code>increment</code>函数，因为<code>this</code>绑定在了我们组件的实例上。有一些方法可以修正它 (<a href=\"https://egghead.io/lessons/javascript-public-class-fields-with-react-components\" target=\"_blank\" rel=\"external\">观看免费视频教程 egghead.io video 💻 </a>)。</p>\n<blockquote>\n<p>事实上你不得不考虑<code>this</code>增加了你的认知负荷，最好避免使用它。</p>\n</blockquote>\n<h3 id=\"如何避免-this\"><a href=\"#如何避免-this\" class=\"headerlink\" title=\"如何避免 this\"></a>如何避免 <code>this</code></h3><p>如果<code>this</code>增加了很多复杂度，我们如何在不添加更复杂代码的基础上避免它。替代面向对象的方法，我们试试函数式的方法如何？如果我们使用<a href=\"https://en.wikipedia.org/wiki/Pure_function\" target=\"_blank\" rel=\"external\">纯函数</a>看起来会是这样：</p>\n<p>用这种方法，我们不会用到<code>this</code>。我们无需考虑它。最终，它也很容易理解。只是函数和对象。基本上没有状态，你只需要注意这些函数，这种感觉很棒！<code>person</code>对象只是数据，所以更容易思考：</p>\n<p><img src=\"http://p0.qhimg.com/t01a2a827ff8e8b46d8.png\" alt=\"\"></p>\n<p><code>person3</code> 对象只有问候和名字</p>\n<p>函数式编程的另一个优势是很容易进行单元测试。你可以简单的调用函数并断言它的输出。在这之前，你无需设定任何状态。这是一个非常方便的特性。</p>\n<p>注意，只要它“足够快”，函数式编程可以让代码更容易理解。尽管执行速度不是重点，在特定场景下你可使用特定的方式来获得更好的性能表现（例如用<code>===</code>来检查对象）。通常，<strong>使用函数式编程的瓶颈是它让你的应用变慢</strong>。</p>\n<h3 id=\"成本和收益\"><a href=\"#成本和收益\" class=\"headerlink\" title=\"成本和收益\"></a>成本和收益</h3><p><code>class</code>的使用并不坏，它的确有它的使用场景。如果你真的有一些 <a href=\"https://en.wikipedia.org/wiki/Hot_spot_%28computer_programming%29\" target=\"_blank\" rel=\"external\">“hot” code</a> 并且已经成为你应用的瓶颈，这时用<code>class</code>真的可以加快速度。但 99% 的时候，情况并非如此。我不认为<code>class</code>和<code>this</code>增加的复杂度在大部分情况下是值得的（我们甚至没有使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"external\">原型继承</a>）。我也有需要使用<code>class</code>来获得更好的性能的时候。我只在 React 组件上使用它们，因为如果你使用状态或者生命周期方法你必须使用它们（<a href=\"https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State\" target=\"_blank\" rel=\"external\">未来</a>可能不会）</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>在 JavaScript 中类（和原型）有它们的使用场景。但它们是一种优化。它们没能让你的代码更加简单，反而更加复杂。所以最好把你的关注点集中在不仅学起来简单而且也容易理解的：函数和对象上。</p>\n<p><img src=\"http://p0.qhimg.com/t01fb9a93490708dc6e.png\" alt=\"\"></p>\n<p><a href=\"https://twitter.com/kentcdodds\" target=\"_blank\" rel=\"external\">再见</a>朋友们!</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>什么时候使用类，什么时候不使用，怎么替代它，为什么替代它</em></p>\n<p><img src=\"http://p0.qhimg.com/t01ec95dba8bdafa400.jpg\" alt=\"\"></p>\n<p><em>译者水平有限，原汁原味请移步：<a href=\"https://medium.com/@kentcdodds/classes-complexity-and-functional-programming-a8dd86903747/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<p>Obligatory semi-to-not-related header image via: <a href=\"https://unsplash.com/photos/sMQiL_2v4vs\" target=\"_blank\" rel=\"external\">https://unsplash.com/photos/sMQiL_2v4vs</a></p>\n<p>当涉及到应用计划持续维护的时候，我们都希望有易维护的简单代码。我们也经常争论如何实现它。在这篇博客中，我将讨论我如何看待函数，对象和类，刚好也符合这个争论。</p>\n<h3 id=\"一个类\"><a href=\"#一个类\" class=\"headerlink\" title=\"一个类\"></a>一个类</h3><p>让我们看看一个类的例子来说明我的观点：</p>\n<p>我们通过构造函数实例化声明了一个<code>Person</code>类，它拥有一些属性和方法。如果我们从 Chrome 的控制台打印出<code>Person</code>对象，它看起来像这样：</p>\n<p><img src=\"http://p0.qhimg.com/t016be2e1b19b3063b3.png\" alt=\"\"></p>\n<p>在<strong>proto</strong>上拥有方法的 Person 实例</p>\n<p>这里真正值得注意的地方是，这个<code>person</code>的大部分属性都在<code>prototype</code>上（在屏幕上以<code>_proto_</code>显示）而不是<code>person</code>实例上。这是非常重要的，因为如果我们有一万个<code>person</code>实例，他们能够在同样的方法上共享引用而不是有一万个那些方法的拷贝。</p>\n<p>现在我想关注的是想要理解这段代码，你需要需要学习多少概念并且那些概念有多么复杂。</p>\n<ul>\n<li><p>对象：相当基础。绝对的入门级。它们不会增加复杂度。</p>\n</li>\n<li><p>函数(和<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"external\">闭包</a>): 这也相当的基础。闭包的确增加了一点复杂度(并且如果你不小心，它能引发一些<a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"external\">问题</a> ), 但是不学习它们，你真的无法在 JavaScript 语言走得更远些 (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"external\">这里</a>可以学到更多).</p>\n</li>\n<li><p>一个函数或者方法的<code>this</code>关键字：JavaScript 中非常重要的概念。</p>\n</li>\n</ul>\n<blockquote>\n<p>我的观点是<code>this</code>学起来比较困难并且给代码增加了不必要的复杂度</p>\n</blockquote>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a><code>this</code>关键字</h3><p>这里是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"external\">MDN</a> 关于<code>this</code>的介绍</p>\n<blockquote>\n<p>JavaScript 中<strong>函数的<code>this</code>关键字</strong>跟其他语言有点不同。并且在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode\" target=\"_blank\" rel=\"external\">严格模式</a>和非严格模式下也有些不同。</p>\n<p>大多数情况下，<code>this</code>的值取决于被调用的函数。执行过程中，不能被重新赋值，并且每次函数调用的时候它都可能不一样。ES5 提供了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"external\"><code>bind</code>方法</a>来绑定一个函数的<code>this</code>值而<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#The_bind_method\" target=\"_blank\" rel=\"external\">不用在意函数调用的方式</a>，并且ES2015提供了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"external\">箭头函数</a>，它的<code>this</code>的作用域是词法作用域（<code>this</code>的值就是当前函数的上下文）。</p>\n</blockquote>\n<p>也许没那么复杂，但这个隐含的关系的确比对象和闭包复杂一点。你不可能避免使用对象和闭包，但我相信大多数情况你能避免使用类和<code>this</code></p>\n<p>这有一个因使用<code>this</code>出错的例子（故意的）：</p>\n<blockquote>\n<p>核心问题是因为使用<code>this</code>你的函数因为各种各样的引用变得混乱不堪。</p>\n</blockquote>\n<p>想要一个更真实的例子，你可在 React ⚛️ 中寻找。如果你已经使用了 React 一段时间，你可能已经遇到了我之前遇到的错误：</p>\n<p>当你点击一个按钮的时候，你会看到： <code>Uncaught TypeError: Cannot read property &#39;setState&#39; of null at increment</code></p>\n<p>这都是因为<code>this</code>的缘故，当我们执行<code>onClick</code>时，它没有调用我们的<code>increment</code>函数，因为<code>this</code>绑定在了我们组件的实例上。有一些方法可以修正它 (<a href=\"https://egghead.io/lessons/javascript-public-class-fields-with-react-components\" target=\"_blank\" rel=\"external\">观看免费视频教程 egghead.io video 💻 </a>)。</p>\n<blockquote>\n<p>事实上你不得不考虑<code>this</code>增加了你的认知负荷，最好避免使用它。</p>\n</blockquote>\n<h3 id=\"如何避免-this\"><a href=\"#如何避免-this\" class=\"headerlink\" title=\"如何避免 this\"></a>如何避免 <code>this</code></h3><p>如果<code>this</code>增加了很多复杂度，我们如何在不添加更复杂代码的基础上避免它。替代面向对象的方法，我们试试函数式的方法如何？如果我们使用<a href=\"https://en.wikipedia.org/wiki/Pure_function\" target=\"_blank\" rel=\"external\">纯函数</a>看起来会是这样：</p>\n<p>用这种方法，我们不会用到<code>this</code>。我们无需考虑它。最终，它也很容易理解。只是函数和对象。基本上没有状态，你只需要注意这些函数，这种感觉很棒！<code>person</code>对象只是数据，所以更容易思考：</p>\n<p><img src=\"http://p0.qhimg.com/t01a2a827ff8e8b46d8.png\" alt=\"\"></p>\n<p><code>person3</code> 对象只有问候和名字</p>\n<p>函数式编程的另一个优势是很容易进行单元测试。你可以简单的调用函数并断言它的输出。在这之前，你无需设定任何状态。这是一个非常方便的特性。</p>\n<p>注意，只要它“足够快”，函数式编程可以让代码更容易理解。尽管执行速度不是重点，在特定场景下你可使用特定的方式来获得更好的性能表现（例如用<code>===</code>来检查对象）。通常，<strong>使用函数式编程的瓶颈是它让你的应用变慢</strong>。</p>\n<h3 id=\"成本和收益\"><a href=\"#成本和收益\" class=\"headerlink\" title=\"成本和收益\"></a>成本和收益</h3><p><code>class</code>的使用并不坏，它的确有它的使用场景。如果你真的有一些 <a href=\"https://en.wikipedia.org/wiki/Hot_spot_%28computer_programming%29\" target=\"_blank\" rel=\"external\">“hot” code</a> 并且已经成为你应用的瓶颈，这时用<code>class</code>真的可以加快速度。但 99% 的时候，情况并非如此。我不认为<code>class</code>和<code>this</code>增加的复杂度在大部分情况下是值得的（我们甚至没有使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"external\">原型继承</a>）。我也有需要使用<code>class</code>来获得更好的性能的时候。我只在 React 组件上使用它们，因为如果你使用状态或者生命周期方法你必须使用它们（<a href=\"https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State\" target=\"_blank\" rel=\"external\">未来</a>可能不会）</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>在 JavaScript 中类（和原型）有它们的使用场景。但它们是一种优化。它们没能让你的代码更加简单，反而更加复杂。所以最好把你的关注点集中在不仅学起来简单而且也容易理解的：函数和对象上。</p>\n<p><img src=\"http://p0.qhimg.com/t01fb9a93490708dc6e.png\" alt=\"\"></p>\n<p><a href=\"https://twitter.com/kentcdodds\" target=\"_blank\" rel=\"external\">再见</a>朋友们!</p>\n"},{"title":"深入剖析现代 JavaScript 应用","date":"2017-06-16T10:01:17.000Z","_content":"![A woman playing a life-size game of Operation; a metaphor for the many components of a modern JavaScript app](http://p0.qhimg.com/t01e14535b49b558b41.png)\n\n_译者能力一般，水平有限，原汁原味请移步：[原文链接](https://www.sitepoint.com/anatomy-of-a-modern-javascript-application/)_\n\n毫无疑问，JS 生态圈变化飞快。不仅仅新的工具与框架被快速的引入和开发，随着 ES2015（又名 ES6）的推出，JS 语言本身也经历了很大的变革。所以，已经有很多文章抱怨现在学习JavaScript 开发是多么的艰难。\n\n在这篇文章中，我将为你介绍现代 JavaScript。我们将看到这门语言最近的发展，并大概了解一下最近编写前端 Web 应用常用的工具与技术。如果你刚开始学习这门语言，或者最近几年没有碰过它并且想知道跟之前相比JavaScript发生了多大的变化，那么这篇文章再好不过。\n\n## 关于 Node.js\n\nNode.js 是一个用 JavaScript 代码编写的服务端程序运行环境。这使得全栈 JavaScript 应用成为可能，应用的前后端用同一种语言编写。虽然这篇文章的重点在客户端开发，但 Node.js 仍然扮演了一个重要的角色。\n\nNode.js 的出现对 JavaScript 生态圈产生了重大的影响，它引入了 npm 包管理工具并且推广了 CommonJS 模块规范。开发者开始发明更具创新性的工具和方法来模糊浏览器、服务器和原生应用之间的界限。\n\n## JavaScript ES2015+\n\n在 2005 年， 第六版 [ECMAScript](https://en.wikipedia.org/wiki/ECMAScript)——制定 JavaScript 语言规范——以 [ES2015](http://www.ecma-international.org/ecma-262/6.0/)（也经常被称为 ES6）的名称发布。新版本添加的大量的特性使得在构建大型 Web 应用的时候更加的轻松和灵活。但是改进的脚步并没有在 ES2015 停止，每年都将发布一个新的版本。\n\n### 变量声明\n\n现在 JavaScript 有两种额外的方式用来声明变量：[**let** 和 **const**](https://www.sitepoint.com/how-to-declare-variables-javascript/)。\n\n`let` 是 `var` 的继任 - 虽然 `var` 依旧可用，`let` 提供了它所声明时所在块的块级作用域（而不是函数作用域），这将减少出错的几率：\n\n```\n// ES5\nfor (var i = 1; i < 5; i++) {\n  console.log(i);\n}\n// <-- 打印数字 1 到 4\nconsole.log(i);\n// <-- 5（变量 i 在循环外仍然存在）\n\n// ES2015\nfor (let j = 1; j < 5; j++) {\n  console.log(j);\n}\nconsole.log(j);\n// <-- 'Uncaught ReferenceError: j is not defined'\n\n```\n\n使用 `const` 允许你定义一个不能被重新绑定到新值的变量。对像字符串和数字的原始值来说，结果与常量类似，一旦你声明一个值，你就不能改变它了。\n\n```\nconst name = 'Bill';\nname = 'Steve';\n// <-- 'Uncaught TypeError: Assignment to constant variable.'\n\n// Gotcha\nconst person = { name: 'Bill' };\nperson.name = 'Steve';\n// person.name is now Steve. \n// As we're not changing the object that person is bound to, JavaScript doesn't complain.\n\n```\n\n### 箭头函数\n\n箭头函数为声明匿名函数提供了一套简洁的语法，当函数体只有一个表达式的时候，省略了 `function` 关键字和 `return` 关键字。这使得可以用更好的方式来编写函数式代码。\n\n```\n// ES5\nvar add = function(a, b) {\n  return a + b;\n}\n\n// ES2015\nconst add = (a, b) => a + b;\n\n```\n\n箭头函数另一个重要的特性是在被定义的上下文中他们继承了 `this` 的值\n\n```\nfunction Person(){\n  this.age = 0;\n\n  // ES5\n  setInterval(function() {\n    this.age++; // |this| refers to the global object\n  }, 1000);\n\n  // ES2015\n  setInterval(() => {\n    this.age++; // |this| properly refers to the person object\n  }, 1000);\n}\n\nvar p = new Person();\n\n```\n\n### 改进类的语法\n\n如果你喜欢面向对象编程，你可能喜欢这门语言在基于原型的基础上对类的扩展。虽然它只是语法糖，但对那些试图通过原型来效仿经典的面向对象的开发者来说，它提供了更简洁的语法。\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\n```\n\n### Promises / Async 函数\n\nJavaScript 的异步特性是长期以来的挑战：当处理像 Ajax 请求这种事情的时候，任何复杂一点的应用都有陷入回调地狱的风险。\n\n幸好，ES2015 用 [promises](https://www.sitepoint.com/deeper-dive-javascript-promises/) 提供了原生支持。Promises 代表着当前不存在但随后可能会存在的值，使得对异步函数调用的管理更加可控，而不必使用多层嵌套回调。\n\nES2017（今年推出）采用了 [async 函数](https://www.sitepoint.com/simplifying-asynchronous-coding-async-functions/)（参考了 async/await 使得这种情况有所改善，允许用同步的方式处理异步代码）。\n\n```\nasync function doAsyncOp () {\n  const result = await asynchronousOperation();     \n  console.log(result);\n  return result;\n};\n\n```\n\n### 模块\n\nES2015 增添的另外一个突出特性是一个原生的模块规范，使得模块的定义和使用成为这门语言的一部分。之前模块的加载只能通过第三方类库的方式。在下一节，我们将深入了解一下模块。\n\n其他的特性我们不会在这里讨论，但我们已经顾及到了一些，当学习现代 JavaScript 时，可能会遇到的主要区别。在 [Babel site](https://babeljs.io/) 的 [Learn ES2015](https://babeljs.io/learn-es2015/) 页面上，你能得到完整的实例清单，并且你可能会找到一些有用的东西来帮你了解这门语言的最新特性。这些特性包括模板字符串，迭代器，生成器，像映射和集合新的数据结构等等。\n\n> 想学习 ES2015 的更多内容，关注我们的收费课程: [Diving into ES2015](https://www.sitepoint.com/premium/courses/diving-into-es2015-2924)\n\n### 代码检查\n\n检查器是解析你的代码并对比是否违反一系列规则，检查语法错误，格式化和最佳实践的工具。虽然对每个人来说都推荐使用检查器，但它对新手来讲更加有用。当正确配置了代码编辑器或集成开发工具后，当正在学习一门新的语言特性时，你能得到及时的反馈来确保没有遇到语法错误。\n\n你可以[查看 ESLint](https://www.sitepoint.com/up-and-running-with-eslint-the-pluggable-javascript-linter/)，它是最流行的之一并且支持 ES2015+。\n\n## 模块化编程\n\n现代 Web 应用有几千（甚至几十万）行代码。如果没有一个通过较小组件，模块化的代码和必要的代码复用进行组合的机制，在这样的代码量下工作几乎是不可能的。这就是模块的工作。\n\n### CommonJS 模块\n\n有些模块规范已经出现几年了，最流行的一个是 [CommonJS](https://en.wikipedia.org/wiki/CommonJS)。它是 Node.js 的默认模块规范，可以通过模块绑定的协助用在客户端，一会儿我们将讨论它。\n\n它通过一个 `module` 对象来输出来自于一个 JavaScript 文件的功能，并且通过一个 `require()` 函数来引入你所需要的功能。\n\n```\n// lib/math.js\nfunction sum(x, y) {\n  return x + y;\n}\n\nconst pi = 3.141593\n\nmodule.exports = {\n  sum: sum,\n  pi: pi\n};\n\n// app.js\nconst math = require(\"lib/math\");\n\nconsole.log(\"2π = \" + math.sum(math.pi, math.pi));\n\n```\n\n### ES2015 模块\n\nES2015 采用了在语言中定义和使用组件的方法，之前可能只用在第三方类库中。你能根据你想要的功能来编写单独的文件并且只输出可用于应用的那一部分。\n\n> **Note**: 原生浏览器对 ES2015 模块的支持还在开发中，所以当前你需要一些额外的工具的帮助才能使用它们。\n\n这有一个例子:\n\n```\n// lib/math.js\n\nexport function sum(x, y) {\n  return x + y;\n}\nexport let pi = 3.141593;\n\n```\n\n我们有输出一个函数和一个变量的模块。我们可以将该文件包含在另外一个文件中并且使用这些输出的函数。\n\n```\n// app.js\n\nimport * as math from \"lib/math\";\n\nconsole.log(\"2π = \" + math.sum(math.pi, math.pi));\n\n```\n\n或者我们也可以指定和只引入我们需要的\n\n```\n// otherApp.js\n\nimport {sum, pi} from \"lib/math\";\n\nconsole.log(\"2π = \" + sum(pi, pi));\n\n```\n\n这些例子摘录于 [Babel website](https://babeljs.io/learn-es2015)。想要深入了解，请查看 [Understanding ES6 Modules](https://www.sitepoint.com/understanding-es6-modules/)。\n\n## 包管理\n\n长期以来，其他语言都有它们自己的包存储和管理工具，使得寻找和安装第三方类库与组件非常的容易。Node.js 有它自己的包管理和仓库， [npm](https://www.sitepoint.com/beginners-guide-node-package-manager/)。虽然也有其他可用的包管理工具，但 npm 已经成为事实上的 JavaScript 包管理工具并且据说有着世界上最大的包注册量。\n\n在 [npm 仓库](https://www.npmjs.com/)，通过一个单独的 `npm install` 命令就能把想要的第三方模块轻易下载到并使用在项目中。这个包下载到本地 `node_modules` 目录，其中包含了所有的包和它们各自的依赖包。\n\n你下载的包可作为依赖被注册在项目中的 [package.json](https://docs.npmjs.com/files/package.json) 文件中，以及项目或模块（在 npm 上它本身可以当做一个包发布）的有关信息。\n\n你能为开发环境和生产环境分别定义依赖包。生产依赖包为工作需要，开发依赖包只对开发者是必需的。\n\n**package.json 文件示例**\n\n```\n{\n  \"name\": \"demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Demo package.json\",\n  \"main\": \"main.js\",\n  \"dependencies\": {\n    \"mkdirp\": \"^0.5.1\",\n    \"underscore\": \"^1.8.3\"\n  },\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"Sitepoint\",\n  \"license\": \"ISC\"\n}\n\n```\n\n## 构建工具\n\n我们开发现代 Web 应用时所写的代码跟将要用在生产环境中的几乎从来不一样。我们编写的最新版 JavaScript 代码可能不被浏览器所支持，我们需要大量使用那些在 `node_modules` 文件夹中第三方包以及它们各自的依赖，我们有静态分析工具或压缩工具等等。构建工具的出现帮助我们把这些转换成更有部署效率并且可以被大多数 Web 浏览器执行的代码。\n\n### 模块打包\n\n当使用 ES2015/CommonJS 模块编写简洁，可复用的代码时，我们需要加载这些模块的方法（至少直到原生浏览器支持 ES2015 模块加载）。HTML 中包含一堆脚本标签对任何严肃的应用来说真不是一个可行的选择，这将很快变得笨重起来，并且所有这些分离的 HTTP 请求将会影响性能。\n\n我们可以使用 ES2015 的 `import` 命令（或CommonJS的 `require`）把我们需要的全部模块引入进来并且通过一个模块打包工具把这些模块组合成一个或多个文件（打包）。我们会把这个打包好的文件上传至服务器并且包含在 HTML 文件中。它将包含你引入的所有模块和它们必需的依赖。\n\n时下有几个热门的选择，最流行的有 [Webpack](http://webpack.js.org), [Browserify](http://browserify.org) 和 [Rollup.js](http://rollupjs.org)。你可根据你的需求，任选一个。\n\n> 如果你想深入学习模块打包机制和如何适应更大规模的应用开发，推荐阅读 [Understanding JavaScript Modules: Bundling & Transpiling](https://www.sitepoint.com/javascript-modules-bundling-transpiling/)。\n\n### 转换编译\n\n虽然[现代浏览器对 ES2015 的支持很好](http://kangax.github.io/compat-table/es6/)，但你的目标用户可能包括低版本浏览器和部分不支持设备的使用者。\n\n为了让现代 JavaScript 代码执行，我们需要把我们所写的代码转化成功能一样的早期版本（通常是 ES5）。执行此项任务的标准工具是 [Babel](https://babeljs.io)；一个把你的代码转换成兼容大多数浏览器的编译器。这样你就不必等着供应商去实现所有的这一切，现在就可以使用现代 JS 的所有特性。\n\n有一些特性仅仅靠语法转换实现不了；Babel 有一个 [Polyfill](http://babeljs.io/docs/usage/polyfill/)， 可以帮助模拟一些更复杂的特性，像 Promises。\n\n### 构建系统和任务自动化\n\n模块打包和转换编译只是我们项目所需要的构建过程中的两步。其他的像代码压缩（为了减小文件大小），分析工具，和一些与 JavaScript 无关的任务，像图像优化和 CSS/HTML 预处理。\n\n任务管理成为一件比较费事的事情，并且我们需要一个自动化的方式来处理它，通过一些简单的命令就能执行所有的一切。最流行的两个工具是 [Grunt.js](http://gruntjs.com) 和 [Gulp.js](http://gulpjs.com)，它们提供了一个方法来把你的任务有序的组成一组。\n\n例如，你能通过一个像 `gulp build` 的命令执行一个代码检查器，Babel 的编译过程和 Browserify 的模块打包过程。而不必按顺序记住三个命令和相关参数，我们只执行可以自动化处理全部过程的一个命令而已。\n\n当你发现需要自己手动处理一些项目中的步骤，考虑它是否能通过任务工具自动化执行。\n\n> **扩展阅读**: [An Introduction to Gulp.js](https://www.sitepoint.com/introduction-gulp-js/)\n\n## 应用架构\n\n跟网站相比，Web 应用有不同的需求。例如，页面重载对一个博客来说可能可以接受，但对应用来说一定不是这样，比如 Google Docs。你的应用应该尽可能表现的像一个桌面应用，否则，可用性将大打折扣。\n\n老式的 Web 应用通常通过 Web 服务器发送几个页面来完成，当需要很多动态变化的时候，根据用户的操作通过 Ajax 替换 HTML 块来加载内容。虽然对动态网页来说，这是一个很大的进步，但它仍有其局限性；用户的每一步操作都要发送 HTML 片段或者整个页面是一种资源的浪费，尤其是从用户的角度来看。可用性仍然达不到桌面应用的响应速度。\n\n为了改善这种状况，我们发明了一种创建 Web 应用的新方法，通过客户端和服务端通信的方式呈现给用户。虽然应用对 JavaScript 需求量大大提高，结果是应用现在的表现跟原生的非常接近；没有页面重载和我们点击按钮时的长时间等待。\n\n### 单页应用\n\nWeb 应用最普通的高级架构被称作 [SPA](https://en.wikipedia.org/wiki/Single-page_application)， _Single Page Application_ 的简写。SPAs 是包含了应用可以正确工作所需的 JavaScript 的大块的集合。界面完全在客户端渲染，所以不需要重新加载。唯一需要变化的东西是应用中的数据，通常通过 [Ajax](https://en.wikipedia.org/wiki/Ajax_(programming)) 的远程 API 或者其他的异步通信方法来处理。\n\n这种方式的一个缺点就是应用首次加载需要耗费很长时间。一旦它完成加载，那么，页面之间的切换将非常流畅，因为只是纯数据在客户端和服务端间传递。\n\n### 通用/同构 应用\n\n虽然 SPAs 提供了很好的用户体验，但取决于你的需求，它们可能不是最佳的解决方案。尤其是你是否需要更快的初始响应时间或者搜索引擎优化。\n\n有一个相当接近的办法来解决这些问题叫 [同构](http://isomorphic.net/javascript) (或 通用) JavaScript 应用。在这种类型的架构下，大部分代码在服务端和客户端都可以执行。你可以选择在服务端渲染用来获得更快的首屏加载速度，在这之后，用户和应用之间的交互通过客户端来渲染。因为页面最初在服务端渲染，所以搜索引擎可以正确的拿到索引。\n\n## 部署\n\n现代 JavaScript 应用中，编写的代码和部署到生产环境的代码是不一样的；你只部署构建过程生成的文件。完成这项工作的流程取决于项目的大小，开发人员的数量和使用的工具与类库。\n\n例如，如果你独自编写一个小型项目，每次部署只需要执行构建过程并且上传所生成的文件到 Web 服务器。记住，你只需要上传一个包含了整个应用和依赖的，通过构建过程（转换编译，模块打包，代码压缩等）生成的单个`.js`文件。\n\n你的目录结构可以这样实现：\n\n```\n├── dist\n│   ├── app.js\n│   └── index.html\n├── node_modules\n├── src\n│   ├── lib\n│   │   ├── login.js\n│   │   └── user.js\n│   ├── app.js\n│   └── index.html\n├── gulpfile.js\n├── package.json\n└── README\n\n```\n\n使用 ES2015 编写的应用文件在`src`目录，通过 npm 安装外部包，自己的模块在`lib`目录下。\n\n然后你可以运行 Gulp，它将会执行`gulpfile.js`中的指令来构建你的项目：打包模块为一个文件（包括通过npm安装的），转换 ES2015+ 到 ES5，压缩生成的文件等。然后你能配置它生成文件到`dist`目录。\n\n> **Note**: 如果你有不需要做任何处理的文件，可以只把它们从`src`下复制到`dist`目录。你也能通过在构建系统中配置任务来完成这个过程。\n\n现在你可以只上传`dist`目录中的文件到 Web 服务器，不必担心剩下的文件，它们只对开发有用。\n\n### 团队开发\n\n如果你跟其他开发者共同开发，你可能也正在使用一个共享的代码库，像 GitHub，来保存你的项目。在这种情况下，你可在提交之前执行构建过程并把生成的文件上传到 Git 仓库，稍后把它下载到生产服务器。\n\n然而，如果多名开发者一起开发时，保存生成的文件到仓库容易出错，并且你也希望保持代码整洁。幸运的是，有个更好的方法来处理这种情况：你可在构建过程中开启一个像 [Jenkins](http://jenkins.io), [Travis CI](http://travis-ci.org), [CircleCI](http://circleci.com) 等这样的服务，这样在每次有新的提交推送到仓库之后，它都可以自动构建你的项目。开发者只关心推送更改的代码而不必每次都构建这个项目，并且自动生成的文件也和仓库保持干净，最后，你仍然有可用的生成文件用来部署。\n\n## 结论\n\n如果近几年你没有接触 Web 开发，那么从简单的 Web 页面到现代 JavaScript 应用之间的转变看起来是令人生畏的，但我希望这篇文章作为一个起点来说是有用的。每个话题我都尽可能的链接了更深入的文章，所以你可以进一步了解。\n\n并且牢记，如果有时候在了解了全部可用选项之后，所有的一起都看起来还是混乱不堪；那就想想 [KISS 准则](https://en.wikipedia.org/wiki/KISS_principle)，并且只用你认为你需要的而不是所有可用的。最终，解决问题才是最重要的，而不是使用最新的东西。\n\n你是如何学习现代 JavaScript 开发的？有没有我还没提到而你想了解的东西？我希望在评论里听到你的声音。\n\n### 作者的更多文章\n\n*   [Create Your Own Yeoman-Style Scaffolding Tool with Caporal.js](https://www.sitepoint.com/scaffolding-tool-caporal-js/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n\n*   [How to Build and Structure a Node.js MVC Application](https://www.sitepoint.com/node-js-mvc-application/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n                \n","source":"_posts/深入剖析现代-JavaScript-应用.md","raw":"---\ntitle: 深入剖析现代 JavaScript 应用\ndate: 2017-06-16 18:01:17\ntags: [JavaScript, 翻译]\n---\n![A woman playing a life-size game of Operation; a metaphor for the many components of a modern JavaScript app](http://p0.qhimg.com/t01e14535b49b558b41.png)\n\n_译者能力一般，水平有限，原汁原味请移步：[原文链接](https://www.sitepoint.com/anatomy-of-a-modern-javascript-application/)_\n\n毫无疑问，JS 生态圈变化飞快。不仅仅新的工具与框架被快速的引入和开发，随着 ES2015（又名 ES6）的推出，JS 语言本身也经历了很大的变革。所以，已经有很多文章抱怨现在学习JavaScript 开发是多么的艰难。\n\n在这篇文章中，我将为你介绍现代 JavaScript。我们将看到这门语言最近的发展，并大概了解一下最近编写前端 Web 应用常用的工具与技术。如果你刚开始学习这门语言，或者最近几年没有碰过它并且想知道跟之前相比JavaScript发生了多大的变化，那么这篇文章再好不过。\n\n## 关于 Node.js\n\nNode.js 是一个用 JavaScript 代码编写的服务端程序运行环境。这使得全栈 JavaScript 应用成为可能，应用的前后端用同一种语言编写。虽然这篇文章的重点在客户端开发，但 Node.js 仍然扮演了一个重要的角色。\n\nNode.js 的出现对 JavaScript 生态圈产生了重大的影响，它引入了 npm 包管理工具并且推广了 CommonJS 模块规范。开发者开始发明更具创新性的工具和方法来模糊浏览器、服务器和原生应用之间的界限。\n\n## JavaScript ES2015+\n\n在 2005 年， 第六版 [ECMAScript](https://en.wikipedia.org/wiki/ECMAScript)——制定 JavaScript 语言规范——以 [ES2015](http://www.ecma-international.org/ecma-262/6.0/)（也经常被称为 ES6）的名称发布。新版本添加的大量的特性使得在构建大型 Web 应用的时候更加的轻松和灵活。但是改进的脚步并没有在 ES2015 停止，每年都将发布一个新的版本。\n\n### 变量声明\n\n现在 JavaScript 有两种额外的方式用来声明变量：[**let** 和 **const**](https://www.sitepoint.com/how-to-declare-variables-javascript/)。\n\n`let` 是 `var` 的继任 - 虽然 `var` 依旧可用，`let` 提供了它所声明时所在块的块级作用域（而不是函数作用域），这将减少出错的几率：\n\n```\n// ES5\nfor (var i = 1; i < 5; i++) {\n  console.log(i);\n}\n// <-- 打印数字 1 到 4\nconsole.log(i);\n// <-- 5（变量 i 在循环外仍然存在）\n\n// ES2015\nfor (let j = 1; j < 5; j++) {\n  console.log(j);\n}\nconsole.log(j);\n// <-- 'Uncaught ReferenceError: j is not defined'\n\n```\n\n使用 `const` 允许你定义一个不能被重新绑定到新值的变量。对像字符串和数字的原始值来说，结果与常量类似，一旦你声明一个值，你就不能改变它了。\n\n```\nconst name = 'Bill';\nname = 'Steve';\n// <-- 'Uncaught TypeError: Assignment to constant variable.'\n\n// Gotcha\nconst person = { name: 'Bill' };\nperson.name = 'Steve';\n// person.name is now Steve. \n// As we're not changing the object that person is bound to, JavaScript doesn't complain.\n\n```\n\n### 箭头函数\n\n箭头函数为声明匿名函数提供了一套简洁的语法，当函数体只有一个表达式的时候，省略了 `function` 关键字和 `return` 关键字。这使得可以用更好的方式来编写函数式代码。\n\n```\n// ES5\nvar add = function(a, b) {\n  return a + b;\n}\n\n// ES2015\nconst add = (a, b) => a + b;\n\n```\n\n箭头函数另一个重要的特性是在被定义的上下文中他们继承了 `this` 的值\n\n```\nfunction Person(){\n  this.age = 0;\n\n  // ES5\n  setInterval(function() {\n    this.age++; // |this| refers to the global object\n  }, 1000);\n\n  // ES2015\n  setInterval(() => {\n    this.age++; // |this| properly refers to the person object\n  }, 1000);\n}\n\nvar p = new Person();\n\n```\n\n### 改进类的语法\n\n如果你喜欢面向对象编程，你可能喜欢这门语言在基于原型的基础上对类的扩展。虽然它只是语法糖，但对那些试图通过原型来效仿经典的面向对象的开发者来说，它提供了更简洁的语法。\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\n```\n\n### Promises / Async 函数\n\nJavaScript 的异步特性是长期以来的挑战：当处理像 Ajax 请求这种事情的时候，任何复杂一点的应用都有陷入回调地狱的风险。\n\n幸好，ES2015 用 [promises](https://www.sitepoint.com/deeper-dive-javascript-promises/) 提供了原生支持。Promises 代表着当前不存在但随后可能会存在的值，使得对异步函数调用的管理更加可控，而不必使用多层嵌套回调。\n\nES2017（今年推出）采用了 [async 函数](https://www.sitepoint.com/simplifying-asynchronous-coding-async-functions/)（参考了 async/await 使得这种情况有所改善，允许用同步的方式处理异步代码）。\n\n```\nasync function doAsyncOp () {\n  const result = await asynchronousOperation();     \n  console.log(result);\n  return result;\n};\n\n```\n\n### 模块\n\nES2015 增添的另外一个突出特性是一个原生的模块规范，使得模块的定义和使用成为这门语言的一部分。之前模块的加载只能通过第三方类库的方式。在下一节，我们将深入了解一下模块。\n\n其他的特性我们不会在这里讨论，但我们已经顾及到了一些，当学习现代 JavaScript 时，可能会遇到的主要区别。在 [Babel site](https://babeljs.io/) 的 [Learn ES2015](https://babeljs.io/learn-es2015/) 页面上，你能得到完整的实例清单，并且你可能会找到一些有用的东西来帮你了解这门语言的最新特性。这些特性包括模板字符串，迭代器，生成器，像映射和集合新的数据结构等等。\n\n> 想学习 ES2015 的更多内容，关注我们的收费课程: [Diving into ES2015](https://www.sitepoint.com/premium/courses/diving-into-es2015-2924)\n\n### 代码检查\n\n检查器是解析你的代码并对比是否违反一系列规则，检查语法错误，格式化和最佳实践的工具。虽然对每个人来说都推荐使用检查器，但它对新手来讲更加有用。当正确配置了代码编辑器或集成开发工具后，当正在学习一门新的语言特性时，你能得到及时的反馈来确保没有遇到语法错误。\n\n你可以[查看 ESLint](https://www.sitepoint.com/up-and-running-with-eslint-the-pluggable-javascript-linter/)，它是最流行的之一并且支持 ES2015+。\n\n## 模块化编程\n\n现代 Web 应用有几千（甚至几十万）行代码。如果没有一个通过较小组件，模块化的代码和必要的代码复用进行组合的机制，在这样的代码量下工作几乎是不可能的。这就是模块的工作。\n\n### CommonJS 模块\n\n有些模块规范已经出现几年了，最流行的一个是 [CommonJS](https://en.wikipedia.org/wiki/CommonJS)。它是 Node.js 的默认模块规范，可以通过模块绑定的协助用在客户端，一会儿我们将讨论它。\n\n它通过一个 `module` 对象来输出来自于一个 JavaScript 文件的功能，并且通过一个 `require()` 函数来引入你所需要的功能。\n\n```\n// lib/math.js\nfunction sum(x, y) {\n  return x + y;\n}\n\nconst pi = 3.141593\n\nmodule.exports = {\n  sum: sum,\n  pi: pi\n};\n\n// app.js\nconst math = require(\"lib/math\");\n\nconsole.log(\"2π = \" + math.sum(math.pi, math.pi));\n\n```\n\n### ES2015 模块\n\nES2015 采用了在语言中定义和使用组件的方法，之前可能只用在第三方类库中。你能根据你想要的功能来编写单独的文件并且只输出可用于应用的那一部分。\n\n> **Note**: 原生浏览器对 ES2015 模块的支持还在开发中，所以当前你需要一些额外的工具的帮助才能使用它们。\n\n这有一个例子:\n\n```\n// lib/math.js\n\nexport function sum(x, y) {\n  return x + y;\n}\nexport let pi = 3.141593;\n\n```\n\n我们有输出一个函数和一个变量的模块。我们可以将该文件包含在另外一个文件中并且使用这些输出的函数。\n\n```\n// app.js\n\nimport * as math from \"lib/math\";\n\nconsole.log(\"2π = \" + math.sum(math.pi, math.pi));\n\n```\n\n或者我们也可以指定和只引入我们需要的\n\n```\n// otherApp.js\n\nimport {sum, pi} from \"lib/math\";\n\nconsole.log(\"2π = \" + sum(pi, pi));\n\n```\n\n这些例子摘录于 [Babel website](https://babeljs.io/learn-es2015)。想要深入了解，请查看 [Understanding ES6 Modules](https://www.sitepoint.com/understanding-es6-modules/)。\n\n## 包管理\n\n长期以来，其他语言都有它们自己的包存储和管理工具，使得寻找和安装第三方类库与组件非常的容易。Node.js 有它自己的包管理和仓库， [npm](https://www.sitepoint.com/beginners-guide-node-package-manager/)。虽然也有其他可用的包管理工具，但 npm 已经成为事实上的 JavaScript 包管理工具并且据说有着世界上最大的包注册量。\n\n在 [npm 仓库](https://www.npmjs.com/)，通过一个单独的 `npm install` 命令就能把想要的第三方模块轻易下载到并使用在项目中。这个包下载到本地 `node_modules` 目录，其中包含了所有的包和它们各自的依赖包。\n\n你下载的包可作为依赖被注册在项目中的 [package.json](https://docs.npmjs.com/files/package.json) 文件中，以及项目或模块（在 npm 上它本身可以当做一个包发布）的有关信息。\n\n你能为开发环境和生产环境分别定义依赖包。生产依赖包为工作需要，开发依赖包只对开发者是必需的。\n\n**package.json 文件示例**\n\n```\n{\n  \"name\": \"demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Demo package.json\",\n  \"main\": \"main.js\",\n  \"dependencies\": {\n    \"mkdirp\": \"^0.5.1\",\n    \"underscore\": \"^1.8.3\"\n  },\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"Sitepoint\",\n  \"license\": \"ISC\"\n}\n\n```\n\n## 构建工具\n\n我们开发现代 Web 应用时所写的代码跟将要用在生产环境中的几乎从来不一样。我们编写的最新版 JavaScript 代码可能不被浏览器所支持，我们需要大量使用那些在 `node_modules` 文件夹中第三方包以及它们各自的依赖，我们有静态分析工具或压缩工具等等。构建工具的出现帮助我们把这些转换成更有部署效率并且可以被大多数 Web 浏览器执行的代码。\n\n### 模块打包\n\n当使用 ES2015/CommonJS 模块编写简洁，可复用的代码时，我们需要加载这些模块的方法（至少直到原生浏览器支持 ES2015 模块加载）。HTML 中包含一堆脚本标签对任何严肃的应用来说真不是一个可行的选择，这将很快变得笨重起来，并且所有这些分离的 HTTP 请求将会影响性能。\n\n我们可以使用 ES2015 的 `import` 命令（或CommonJS的 `require`）把我们需要的全部模块引入进来并且通过一个模块打包工具把这些模块组合成一个或多个文件（打包）。我们会把这个打包好的文件上传至服务器并且包含在 HTML 文件中。它将包含你引入的所有模块和它们必需的依赖。\n\n时下有几个热门的选择，最流行的有 [Webpack](http://webpack.js.org), [Browserify](http://browserify.org) 和 [Rollup.js](http://rollupjs.org)。你可根据你的需求，任选一个。\n\n> 如果你想深入学习模块打包机制和如何适应更大规模的应用开发，推荐阅读 [Understanding JavaScript Modules: Bundling & Transpiling](https://www.sitepoint.com/javascript-modules-bundling-transpiling/)。\n\n### 转换编译\n\n虽然[现代浏览器对 ES2015 的支持很好](http://kangax.github.io/compat-table/es6/)，但你的目标用户可能包括低版本浏览器和部分不支持设备的使用者。\n\n为了让现代 JavaScript 代码执行，我们需要把我们所写的代码转化成功能一样的早期版本（通常是 ES5）。执行此项任务的标准工具是 [Babel](https://babeljs.io)；一个把你的代码转换成兼容大多数浏览器的编译器。这样你就不必等着供应商去实现所有的这一切，现在就可以使用现代 JS 的所有特性。\n\n有一些特性仅仅靠语法转换实现不了；Babel 有一个 [Polyfill](http://babeljs.io/docs/usage/polyfill/)， 可以帮助模拟一些更复杂的特性，像 Promises。\n\n### 构建系统和任务自动化\n\n模块打包和转换编译只是我们项目所需要的构建过程中的两步。其他的像代码压缩（为了减小文件大小），分析工具，和一些与 JavaScript 无关的任务，像图像优化和 CSS/HTML 预处理。\n\n任务管理成为一件比较费事的事情，并且我们需要一个自动化的方式来处理它，通过一些简单的命令就能执行所有的一切。最流行的两个工具是 [Grunt.js](http://gruntjs.com) 和 [Gulp.js](http://gulpjs.com)，它们提供了一个方法来把你的任务有序的组成一组。\n\n例如，你能通过一个像 `gulp build` 的命令执行一个代码检查器，Babel 的编译过程和 Browserify 的模块打包过程。而不必按顺序记住三个命令和相关参数，我们只执行可以自动化处理全部过程的一个命令而已。\n\n当你发现需要自己手动处理一些项目中的步骤，考虑它是否能通过任务工具自动化执行。\n\n> **扩展阅读**: [An Introduction to Gulp.js](https://www.sitepoint.com/introduction-gulp-js/)\n\n## 应用架构\n\n跟网站相比，Web 应用有不同的需求。例如，页面重载对一个博客来说可能可以接受，但对应用来说一定不是这样，比如 Google Docs。你的应用应该尽可能表现的像一个桌面应用，否则，可用性将大打折扣。\n\n老式的 Web 应用通常通过 Web 服务器发送几个页面来完成，当需要很多动态变化的时候，根据用户的操作通过 Ajax 替换 HTML 块来加载内容。虽然对动态网页来说，这是一个很大的进步，但它仍有其局限性；用户的每一步操作都要发送 HTML 片段或者整个页面是一种资源的浪费，尤其是从用户的角度来看。可用性仍然达不到桌面应用的响应速度。\n\n为了改善这种状况，我们发明了一种创建 Web 应用的新方法，通过客户端和服务端通信的方式呈现给用户。虽然应用对 JavaScript 需求量大大提高，结果是应用现在的表现跟原生的非常接近；没有页面重载和我们点击按钮时的长时间等待。\n\n### 单页应用\n\nWeb 应用最普通的高级架构被称作 [SPA](https://en.wikipedia.org/wiki/Single-page_application)， _Single Page Application_ 的简写。SPAs 是包含了应用可以正确工作所需的 JavaScript 的大块的集合。界面完全在客户端渲染，所以不需要重新加载。唯一需要变化的东西是应用中的数据，通常通过 [Ajax](https://en.wikipedia.org/wiki/Ajax_(programming)) 的远程 API 或者其他的异步通信方法来处理。\n\n这种方式的一个缺点就是应用首次加载需要耗费很长时间。一旦它完成加载，那么，页面之间的切换将非常流畅，因为只是纯数据在客户端和服务端间传递。\n\n### 通用/同构 应用\n\n虽然 SPAs 提供了很好的用户体验，但取决于你的需求，它们可能不是最佳的解决方案。尤其是你是否需要更快的初始响应时间或者搜索引擎优化。\n\n有一个相当接近的办法来解决这些问题叫 [同构](http://isomorphic.net/javascript) (或 通用) JavaScript 应用。在这种类型的架构下，大部分代码在服务端和客户端都可以执行。你可以选择在服务端渲染用来获得更快的首屏加载速度，在这之后，用户和应用之间的交互通过客户端来渲染。因为页面最初在服务端渲染，所以搜索引擎可以正确的拿到索引。\n\n## 部署\n\n现代 JavaScript 应用中，编写的代码和部署到生产环境的代码是不一样的；你只部署构建过程生成的文件。完成这项工作的流程取决于项目的大小，开发人员的数量和使用的工具与类库。\n\n例如，如果你独自编写一个小型项目，每次部署只需要执行构建过程并且上传所生成的文件到 Web 服务器。记住，你只需要上传一个包含了整个应用和依赖的，通过构建过程（转换编译，模块打包，代码压缩等）生成的单个`.js`文件。\n\n你的目录结构可以这样实现：\n\n```\n├── dist\n│   ├── app.js\n│   └── index.html\n├── node_modules\n├── src\n│   ├── lib\n│   │   ├── login.js\n│   │   └── user.js\n│   ├── app.js\n│   └── index.html\n├── gulpfile.js\n├── package.json\n└── README\n\n```\n\n使用 ES2015 编写的应用文件在`src`目录，通过 npm 安装外部包，自己的模块在`lib`目录下。\n\n然后你可以运行 Gulp，它将会执行`gulpfile.js`中的指令来构建你的项目：打包模块为一个文件（包括通过npm安装的），转换 ES2015+ 到 ES5，压缩生成的文件等。然后你能配置它生成文件到`dist`目录。\n\n> **Note**: 如果你有不需要做任何处理的文件，可以只把它们从`src`下复制到`dist`目录。你也能通过在构建系统中配置任务来完成这个过程。\n\n现在你可以只上传`dist`目录中的文件到 Web 服务器，不必担心剩下的文件，它们只对开发有用。\n\n### 团队开发\n\n如果你跟其他开发者共同开发，你可能也正在使用一个共享的代码库，像 GitHub，来保存你的项目。在这种情况下，你可在提交之前执行构建过程并把生成的文件上传到 Git 仓库，稍后把它下载到生产服务器。\n\n然而，如果多名开发者一起开发时，保存生成的文件到仓库容易出错，并且你也希望保持代码整洁。幸运的是，有个更好的方法来处理这种情况：你可在构建过程中开启一个像 [Jenkins](http://jenkins.io), [Travis CI](http://travis-ci.org), [CircleCI](http://circleci.com) 等这样的服务，这样在每次有新的提交推送到仓库之后，它都可以自动构建你的项目。开发者只关心推送更改的代码而不必每次都构建这个项目，并且自动生成的文件也和仓库保持干净，最后，你仍然有可用的生成文件用来部署。\n\n## 结论\n\n如果近几年你没有接触 Web 开发，那么从简单的 Web 页面到现代 JavaScript 应用之间的转变看起来是令人生畏的，但我希望这篇文章作为一个起点来说是有用的。每个话题我都尽可能的链接了更深入的文章，所以你可以进一步了解。\n\n并且牢记，如果有时候在了解了全部可用选项之后，所有的一起都看起来还是混乱不堪；那就想想 [KISS 准则](https://en.wikipedia.org/wiki/KISS_principle)，并且只用你认为你需要的而不是所有可用的。最终，解决问题才是最重要的，而不是使用最新的东西。\n\n你是如何学习现代 JavaScript 开发的？有没有我还没提到而你想了解的东西？我希望在评论里听到你的声音。\n\n### 作者的更多文章\n\n*   [Create Your Own Yeoman-Style Scaffolding Tool with Caporal.js](https://www.sitepoint.com/scaffolding-tool-caporal-js/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n\n*   [How to Build and Structure a Node.js MVC Application](https://www.sitepoint.com/node-js-mvc-application/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n                \n","slug":"深入剖析现代-JavaScript-应用","published":1,"updated":"2017-06-25T10:36:20.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4cl7dhn000898vkq4qat55v","content":"<p><img src=\"http://p0.qhimg.com/t01e14535b49b558b41.png\" alt=\"A woman playing a life-size game of Operation; a metaphor for the many components of a modern JavaScript app\"></p>\n<p><em>译者能力一般，水平有限，原汁原味请移步：<a href=\"https://www.sitepoint.com/anatomy-of-a-modern-javascript-application/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<p>毫无疑问，JS 生态圈变化飞快。不仅仅新的工具与框架被快速的引入和开发，随着 ES2015（又名 ES6）的推出，JS 语言本身也经历了很大的变革。所以，已经有很多文章抱怨现在学习JavaScript 开发是多么的艰难。</p>\n<p>在这篇文章中，我将为你介绍现代 JavaScript。我们将看到这门语言最近的发展，并大概了解一下最近编写前端 Web 应用常用的工具与技术。如果你刚开始学习这门语言，或者最近几年没有碰过它并且想知道跟之前相比JavaScript发生了多大的变化，那么这篇文章再好不过。</p>\n<h2 id=\"关于-Node-js\"><a href=\"#关于-Node-js\" class=\"headerlink\" title=\"关于 Node.js\"></a>关于 Node.js</h2><p>Node.js 是一个用 JavaScript 代码编写的服务端程序运行环境。这使得全栈 JavaScript 应用成为可能，应用的前后端用同一种语言编写。虽然这篇文章的重点在客户端开发，但 Node.js 仍然扮演了一个重要的角色。</p>\n<p>Node.js 的出现对 JavaScript 生态圈产生了重大的影响，它引入了 npm 包管理工具并且推广了 CommonJS 模块规范。开发者开始发明更具创新性的工具和方法来模糊浏览器、服务器和原生应用之间的界限。</p>\n<h2 id=\"JavaScript-ES2015\"><a href=\"#JavaScript-ES2015\" class=\"headerlink\" title=\"JavaScript ES2015+\"></a>JavaScript ES2015+</h2><p>在 2005 年， 第六版 <a href=\"https://en.wikipedia.org/wiki/ECMAScript\" target=\"_blank\" rel=\"external\">ECMAScript</a>——制定 JavaScript 语言规范——以 <a href=\"http://www.ecma-international.org/ecma-262/6.0/\" target=\"_blank\" rel=\"external\">ES2015</a>（也经常被称为 ES6）的名称发布。新版本添加的大量的特性使得在构建大型 Web 应用的时候更加的轻松和灵活。但是改进的脚步并没有在 ES2015 停止，每年都将发布一个新的版本。</p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>现在 JavaScript 有两种额外的方式用来声明变量：<a href=\"https://www.sitepoint.com/how-to-declare-variables-javascript/\" target=\"_blank\" rel=\"external\"><strong>let</strong> 和 <strong>const</strong></a>。</p>\n<p><code>let</code> 是 <code>var</code> 的继任 - 虽然 <code>var</code> 依旧可用，<code>let</code> 提供了它所声明时所在块的块级作用域（而不是函数作用域），这将减少出错的几率：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">for (var i = 1; i &lt; 5; i++) &#123;</div><div class=\"line\">  console.log(i);</div><div class=\"line\">&#125;</div><div class=\"line\">// &lt;-- 打印数字 1 到 4</div><div class=\"line\">console.log(i);</div><div class=\"line\">// &lt;-- 5（变量 i 在循环外仍然存在）</div><div class=\"line\"></div><div class=\"line\">// ES2015</div><div class=\"line\">for (let j = 1; j &lt; 5; j++) &#123;</div><div class=\"line\">  console.log(j);</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(j);</div><div class=\"line\">// &lt;-- &apos;Uncaught ReferenceError: j is not defined&apos;</div></pre></td></tr></table></figure>\n<p>使用 <code>const</code> 允许你定义一个不能被重新绑定到新值的变量。对像字符串和数字的原始值来说，结果与常量类似，一旦你声明一个值，你就不能改变它了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">const name = &apos;Bill&apos;;</div><div class=\"line\">name = &apos;Steve&apos;;</div><div class=\"line\">// &lt;-- &apos;Uncaught TypeError: Assignment to constant variable.&apos;</div><div class=\"line\"></div><div class=\"line\">// Gotcha</div><div class=\"line\">const person = &#123; name: &apos;Bill&apos; &#125;;</div><div class=\"line\">person.name = &apos;Steve&apos;;</div><div class=\"line\">// person.name is now Steve. </div><div class=\"line\">// As we&apos;re not changing the object that person is bound to, JavaScript doesn&apos;t complain.</div></pre></td></tr></table></figure>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数为声明匿名函数提供了一套简洁的语法，当函数体只有一个表达式的时候，省略了 <code>function</code> 关键字和 <code>return</code> 关键字。这使得可以用更好的方式来编写函数式代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">var add = function(a, b) &#123;</div><div class=\"line\">  return a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// ES2015</div><div class=\"line\">const add = (a, b) =&gt; a + b;</div></pre></td></tr></table></figure>\n<p>箭头函数另一个重要的特性是在被定义的上下文中他们继承了 <code>this</code> 的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person()&#123;</div><div class=\"line\">  this.age = 0;</div><div class=\"line\"></div><div class=\"line\">  // ES5</div><div class=\"line\">  setInterval(function() &#123;</div><div class=\"line\">    this.age++; // |this| refers to the global object</div><div class=\"line\">  &#125;, 1000);</div><div class=\"line\"></div><div class=\"line\">  // ES2015</div><div class=\"line\">  setInterval(() =&gt; &#123;</div><div class=\"line\">    this.age++; // |this| properly refers to the person object</div><div class=\"line\">  &#125;, 1000);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Person();</div></pre></td></tr></table></figure>\n<h3 id=\"改进类的语法\"><a href=\"#改进类的语法\" class=\"headerlink\" title=\"改进类的语法\"></a>改进类的语法</h3><p>如果你喜欢面向对象编程，你可能喜欢这门语言在基于原型的基础上对类的扩展。虽然它只是语法糖，但对那些试图通过原型来效仿经典的面向对象的开发者来说，它提供了更简洁的语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Person &#123;</div><div class=\"line\">  constructor(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  greet() &#123;</div><div class=\"line\">    console.log(`Hello, my name is $&#123;this.name&#125;`);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Promises-Async-函数\"><a href=\"#Promises-Async-函数\" class=\"headerlink\" title=\"Promises / Async 函数\"></a>Promises / Async 函数</h3><p>JavaScript 的异步特性是长期以来的挑战：当处理像 Ajax 请求这种事情的时候，任何复杂一点的应用都有陷入回调地狱的风险。</p>\n<p>幸好，ES2015 用 <a href=\"https://www.sitepoint.com/deeper-dive-javascript-promises/\" target=\"_blank\" rel=\"external\">promises</a> 提供了原生支持。Promises 代表着当前不存在但随后可能会存在的值，使得对异步函数调用的管理更加可控，而不必使用多层嵌套回调。</p>\n<p>ES2017（今年推出）采用了 <a href=\"https://www.sitepoint.com/simplifying-asynchronous-coding-async-functions/\" target=\"_blank\" rel=\"external\">async 函数</a>（参考了 async/await 使得这种情况有所改善，允许用同步的方式处理异步代码）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function doAsyncOp () &#123;</div><div class=\"line\">  const result = await asynchronousOperation();     </div><div class=\"line\">  console.log(result);</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>ES2015 增添的另外一个突出特性是一个原生的模块规范，使得模块的定义和使用成为这门语言的一部分。之前模块的加载只能通过第三方类库的方式。在下一节，我们将深入了解一下模块。</p>\n<p>其他的特性我们不会在这里讨论，但我们已经顾及到了一些，当学习现代 JavaScript 时，可能会遇到的主要区别。在 <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"external\">Babel site</a> 的 <a href=\"https://babeljs.io/learn-es2015/\" target=\"_blank\" rel=\"external\">Learn ES2015</a> 页面上，你能得到完整的实例清单，并且你可能会找到一些有用的东西来帮你了解这门语言的最新特性。这些特性包括模板字符串，迭代器，生成器，像映射和集合新的数据结构等等。</p>\n<blockquote>\n<p>想学习 ES2015 的更多内容，关注我们的收费课程: <a href=\"https://www.sitepoint.com/premium/courses/diving-into-es2015-2924\" target=\"_blank\" rel=\"external\">Diving into ES2015</a></p>\n</blockquote>\n<h3 id=\"代码检查\"><a href=\"#代码检查\" class=\"headerlink\" title=\"代码检查\"></a>代码检查</h3><p>检查器是解析你的代码并对比是否违反一系列规则，检查语法错误，格式化和最佳实践的工具。虽然对每个人来说都推荐使用检查器，但它对新手来讲更加有用。当正确配置了代码编辑器或集成开发工具后，当正在学习一门新的语言特性时，你能得到及时的反馈来确保没有遇到语法错误。</p>\n<p>你可以<a href=\"https://www.sitepoint.com/up-and-running-with-eslint-the-pluggable-javascript-linter/\" target=\"_blank\" rel=\"external\">查看 ESLint</a>，它是最流行的之一并且支持 ES2015+。</p>\n<h2 id=\"模块化编程\"><a href=\"#模块化编程\" class=\"headerlink\" title=\"模块化编程\"></a>模块化编程</h2><p>现代 Web 应用有几千（甚至几十万）行代码。如果没有一个通过较小组件，模块化的代码和必要的代码复用进行组合的机制，在这样的代码量下工作几乎是不可能的。这就是模块的工作。</p>\n<h3 id=\"CommonJS-模块\"><a href=\"#CommonJS-模块\" class=\"headerlink\" title=\"CommonJS 模块\"></a>CommonJS 模块</h3><p>有些模块规范已经出现几年了，最流行的一个是 <a href=\"https://en.wikipedia.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a>。它是 Node.js 的默认模块规范，可以通过模块绑定的协助用在客户端，一会儿我们将讨论它。</p>\n<p>它通过一个 <code>module</code> 对象来输出来自于一个 JavaScript 文件的功能，并且通过一个 <code>require()</code> 函数来引入你所需要的功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib/math.js</div><div class=\"line\">function sum(x, y) &#123;</div><div class=\"line\">  return x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const pi = 3.141593</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  sum: sum,</div><div class=\"line\">  pi: pi</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">const math = require(&quot;lib/math&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;2π = &quot; + math.sum(math.pi, math.pi));</div></pre></td></tr></table></figure>\n<h3 id=\"ES2015-模块\"><a href=\"#ES2015-模块\" class=\"headerlink\" title=\"ES2015 模块\"></a>ES2015 模块</h3><p>ES2015 采用了在语言中定义和使用组件的方法，之前可能只用在第三方类库中。你能根据你想要的功能来编写单独的文件并且只输出可用于应用的那一部分。</p>\n<blockquote>\n<p><strong>Note</strong>: 原生浏览器对 ES2015 模块的支持还在开发中，所以当前你需要一些额外的工具的帮助才能使用它们。</p>\n</blockquote>\n<p>这有一个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib/math.js</div><div class=\"line\"></div><div class=\"line\">export function sum(x, y) &#123;</div><div class=\"line\">  return x + y;</div><div class=\"line\">&#125;</div><div class=\"line\">export let pi = 3.141593;</div></pre></td></tr></table></figure>\n<p>我们有输出一个函数和一个变量的模块。我们可以将该文件包含在另外一个文件中并且使用这些输出的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// app.js</div><div class=\"line\"></div><div class=\"line\">import * as math from &quot;lib/math&quot;;</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;2π = &quot; + math.sum(math.pi, math.pi));</div></pre></td></tr></table></figure>\n<p>或者我们也可以指定和只引入我们需要的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// otherApp.js</div><div class=\"line\"></div><div class=\"line\">import &#123;sum, pi&#125; from &quot;lib/math&quot;;</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;2π = &quot; + sum(pi, pi));</div></pre></td></tr></table></figure>\n<p>这些例子摘录于 <a href=\"https://babeljs.io/learn-es2015\" target=\"_blank\" rel=\"external\">Babel website</a>。想要深入了解，请查看 <a href=\"https://www.sitepoint.com/understanding-es6-modules/\" target=\"_blank\" rel=\"external\">Understanding ES6 Modules</a>。</p>\n<h2 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h2><p>长期以来，其他语言都有它们自己的包存储和管理工具，使得寻找和安装第三方类库与组件非常的容易。Node.js 有它自己的包管理和仓库， <a href=\"https://www.sitepoint.com/beginners-guide-node-package-manager/\" target=\"_blank\" rel=\"external\">npm</a>。虽然也有其他可用的包管理工具，但 npm 已经成为事实上的 JavaScript 包管理工具并且据说有着世界上最大的包注册量。</p>\n<p>在 <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">npm 仓库</a>，通过一个单独的 <code>npm install</code> 命令就能把想要的第三方模块轻易下载到并使用在项目中。这个包下载到本地 <code>node_modules</code> 目录，其中包含了所有的包和它们各自的依赖包。</p>\n<p>你下载的包可作为依赖被注册在项目中的 <a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json</a> 文件中，以及项目或模块（在 npm 上它本身可以当做一个包发布）的有关信息。</p>\n<p>你能为开发环境和生产环境分别定义依赖包。生产依赖包为工作需要，开发依赖包只对开发者是必需的。</p>\n<p><strong>package.json 文件示例</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;demo&quot;,</div><div class=\"line\">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class=\"line\">  &quot;description&quot;: &quot;Demo package.json&quot;,</div><div class=\"line\">  &quot;main&quot;: &quot;main.js&quot;,</div><div class=\"line\">  &quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;mkdirp&quot;: &quot;^0.5.1&quot;,</div><div class=\"line\">    &quot;underscore&quot;: &quot;^1.8.3&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;devDependencies&quot;: &#123;&#125;,</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;author&quot;: &quot;Sitepoint&quot;,</div><div class=\"line\">  &quot;license&quot;: &quot;ISC&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"构建工具\"><a href=\"#构建工具\" class=\"headerlink\" title=\"构建工具\"></a>构建工具</h2><p>我们开发现代 Web 应用时所写的代码跟将要用在生产环境中的几乎从来不一样。我们编写的最新版 JavaScript 代码可能不被浏览器所支持，我们需要大量使用那些在 <code>node_modules</code> 文件夹中第三方包以及它们各自的依赖，我们有静态分析工具或压缩工具等等。构建工具的出现帮助我们把这些转换成更有部署效率并且可以被大多数 Web 浏览器执行的代码。</p>\n<h3 id=\"模块打包\"><a href=\"#模块打包\" class=\"headerlink\" title=\"模块打包\"></a>模块打包</h3><p>当使用 ES2015/CommonJS 模块编写简洁，可复用的代码时，我们需要加载这些模块的方法（至少直到原生浏览器支持 ES2015 模块加载）。HTML 中包含一堆脚本标签对任何严肃的应用来说真不是一个可行的选择，这将很快变得笨重起来，并且所有这些分离的 HTTP 请求将会影响性能。</p>\n<p>我们可以使用 ES2015 的 <code>import</code> 命令（或CommonJS的 <code>require</code>）把我们需要的全部模块引入进来并且通过一个模块打包工具把这些模块组合成一个或多个文件（打包）。我们会把这个打包好的文件上传至服务器并且包含在 HTML 文件中。它将包含你引入的所有模块和它们必需的依赖。</p>\n<p>时下有几个热门的选择，最流行的有 <a href=\"http://webpack.js.org\" target=\"_blank\" rel=\"external\">Webpack</a>, <a href=\"http://browserify.org\" target=\"_blank\" rel=\"external\">Browserify</a> 和 <a href=\"http://rollupjs.org\" target=\"_blank\" rel=\"external\">Rollup.js</a>。你可根据你的需求，任选一个。</p>\n<blockquote>\n<p>如果你想深入学习模块打包机制和如何适应更大规模的应用开发，推荐阅读 <a href=\"https://www.sitepoint.com/javascript-modules-bundling-transpiling/\" target=\"_blank\" rel=\"external\">Understanding JavaScript Modules: Bundling &amp; Transpiling</a>。</p>\n</blockquote>\n<h3 id=\"转换编译\"><a href=\"#转换编译\" class=\"headerlink\" title=\"转换编译\"></a>转换编译</h3><p>虽然<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">现代浏览器对 ES2015 的支持很好</a>，但你的目标用户可能包括低版本浏览器和部分不支持设备的使用者。</p>\n<p>为了让现代 JavaScript 代码执行，我们需要把我们所写的代码转化成功能一样的早期版本（通常是 ES5）。执行此项任务的标准工具是 <a href=\"https://babeljs.io\" target=\"_blank\" rel=\"external\">Babel</a>；一个把你的代码转换成兼容大多数浏览器的编译器。这样你就不必等着供应商去实现所有的这一切，现在就可以使用现代 JS 的所有特性。</p>\n<p>有一些特性仅仅靠语法转换实现不了；Babel 有一个 <a href=\"http://babeljs.io/docs/usage/polyfill/\" target=\"_blank\" rel=\"external\">Polyfill</a>， 可以帮助模拟一些更复杂的特性，像 Promises。</p>\n<h3 id=\"构建系统和任务自动化\"><a href=\"#构建系统和任务自动化\" class=\"headerlink\" title=\"构建系统和任务自动化\"></a>构建系统和任务自动化</h3><p>模块打包和转换编译只是我们项目所需要的构建过程中的两步。其他的像代码压缩（为了减小文件大小），分析工具，和一些与 JavaScript 无关的任务，像图像优化和 CSS/HTML 预处理。</p>\n<p>任务管理成为一件比较费事的事情，并且我们需要一个自动化的方式来处理它，通过一些简单的命令就能执行所有的一切。最流行的两个工具是 <a href=\"http://gruntjs.com\" target=\"_blank\" rel=\"external\">Grunt.js</a> 和 <a href=\"http://gulpjs.com\" target=\"_blank\" rel=\"external\">Gulp.js</a>，它们提供了一个方法来把你的任务有序的组成一组。</p>\n<p>例如，你能通过一个像 <code>gulp build</code> 的命令执行一个代码检查器，Babel 的编译过程和 Browserify 的模块打包过程。而不必按顺序记住三个命令和相关参数，我们只执行可以自动化处理全部过程的一个命令而已。</p>\n<p>当你发现需要自己手动处理一些项目中的步骤，考虑它是否能通过任务工具自动化执行。</p>\n<blockquote>\n<p><strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/introduction-gulp-js/\" target=\"_blank\" rel=\"external\">An Introduction to Gulp.js</a></p>\n</blockquote>\n<h2 id=\"应用架构\"><a href=\"#应用架构\" class=\"headerlink\" title=\"应用架构\"></a>应用架构</h2><p>跟网站相比，Web 应用有不同的需求。例如，页面重载对一个博客来说可能可以接受，但对应用来说一定不是这样，比如 Google Docs。你的应用应该尽可能表现的像一个桌面应用，否则，可用性将大打折扣。</p>\n<p>老式的 Web 应用通常通过 Web 服务器发送几个页面来完成，当需要很多动态变化的时候，根据用户的操作通过 Ajax 替换 HTML 块来加载内容。虽然对动态网页来说，这是一个很大的进步，但它仍有其局限性；用户的每一步操作都要发送 HTML 片段或者整个页面是一种资源的浪费，尤其是从用户的角度来看。可用性仍然达不到桌面应用的响应速度。</p>\n<p>为了改善这种状况，我们发明了一种创建 Web 应用的新方法，通过客户端和服务端通信的方式呈现给用户。虽然应用对 JavaScript 需求量大大提高，结果是应用现在的表现跟原生的非常接近；没有页面重载和我们点击按钮时的长时间等待。</p>\n<h3 id=\"单页应用\"><a href=\"#单页应用\" class=\"headerlink\" title=\"单页应用\"></a>单页应用</h3><p>Web 应用最普通的高级架构被称作 <a href=\"https://en.wikipedia.org/wiki/Single-page_application\" target=\"_blank\" rel=\"external\">SPA</a>， <em>Single Page Application</em> 的简写。SPAs 是包含了应用可以正确工作所需的 JavaScript 的大块的集合。界面完全在客户端渲染，所以不需要重新加载。唯一需要变化的东西是应用中的数据，通常通过 <a href=\"https://en.wikipedia.org/wiki/Ajax_(programming\" target=\"_blank\" rel=\"external\">Ajax</a>) 的远程 API 或者其他的异步通信方法来处理。</p>\n<p>这种方式的一个缺点就是应用首次加载需要耗费很长时间。一旦它完成加载，那么，页面之间的切换将非常流畅，因为只是纯数据在客户端和服务端间传递。</p>\n<h3 id=\"通用-同构-应用\"><a href=\"#通用-同构-应用\" class=\"headerlink\" title=\"通用/同构 应用\"></a>通用/同构 应用</h3><p>虽然 SPAs 提供了很好的用户体验，但取决于你的需求，它们可能不是最佳的解决方案。尤其是你是否需要更快的初始响应时间或者搜索引擎优化。</p>\n<p>有一个相当接近的办法来解决这些问题叫 <a href=\"http://isomorphic.net/javascript\" target=\"_blank\" rel=\"external\">同构</a> (或 通用) JavaScript 应用。在这种类型的架构下，大部分代码在服务端和客户端都可以执行。你可以选择在服务端渲染用来获得更快的首屏加载速度，在这之后，用户和应用之间的交互通过客户端来渲染。因为页面最初在服务端渲染，所以搜索引擎可以正确的拿到索引。</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>现代 JavaScript 应用中，编写的代码和部署到生产环境的代码是不一样的；你只部署构建过程生成的文件。完成这项工作的流程取决于项目的大小，开发人员的数量和使用的工具与类库。</p>\n<p>例如，如果你独自编写一个小型项目，每次部署只需要执行构建过程并且上传所生成的文件到 Web 服务器。记住，你只需要上传一个包含了整个应用和依赖的，通过构建过程（转换编译，模块打包，代码压缩等）生成的单个<code>.js</code>文件。</p>\n<p>你的目录结构可以这样实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── dist</div><div class=\"line\">│   ├── app.js</div><div class=\"line\">│   └── index.html</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── src</div><div class=\"line\">│   ├── lib</div><div class=\"line\">│   │   ├── login.js</div><div class=\"line\">│   │   └── user.js</div><div class=\"line\">│   ├── app.js</div><div class=\"line\">│   └── index.html</div><div class=\"line\">├── gulpfile.js</div><div class=\"line\">├── package.json</div><div class=\"line\">└── README</div></pre></td></tr></table></figure>\n<p>使用 ES2015 编写的应用文件在<code>src</code>目录，通过 npm 安装外部包，自己的模块在<code>lib</code>目录下。</p>\n<p>然后你可以运行 Gulp，它将会执行<code>gulpfile.js</code>中的指令来构建你的项目：打包模块为一个文件（包括通过npm安装的），转换 ES2015+ 到 ES5，压缩生成的文件等。然后你能配置它生成文件到<code>dist</code>目录。</p>\n<blockquote>\n<p><strong>Note</strong>: 如果你有不需要做任何处理的文件，可以只把它们从<code>src</code>下复制到<code>dist</code>目录。你也能通过在构建系统中配置任务来完成这个过程。</p>\n</blockquote>\n<p>现在你可以只上传<code>dist</code>目录中的文件到 Web 服务器，不必担心剩下的文件，它们只对开发有用。</p>\n<h3 id=\"团队开发\"><a href=\"#团队开发\" class=\"headerlink\" title=\"团队开发\"></a>团队开发</h3><p>如果你跟其他开发者共同开发，你可能也正在使用一个共享的代码库，像 GitHub，来保存你的项目。在这种情况下，你可在提交之前执行构建过程并把生成的文件上传到 Git 仓库，稍后把它下载到生产服务器。</p>\n<p>然而，如果多名开发者一起开发时，保存生成的文件到仓库容易出错，并且你也希望保持代码整洁。幸运的是，有个更好的方法来处理这种情况：你可在构建过程中开启一个像 <a href=\"http://jenkins.io\" target=\"_blank\" rel=\"external\">Jenkins</a>, <a href=\"http://travis-ci.org\" target=\"_blank\" rel=\"external\">Travis CI</a>, <a href=\"http://circleci.com\" target=\"_blank\" rel=\"external\">CircleCI</a> 等这样的服务，这样在每次有新的提交推送到仓库之后，它都可以自动构建你的项目。开发者只关心推送更改的代码而不必每次都构建这个项目，并且自动生成的文件也和仓库保持干净，最后，你仍然有可用的生成文件用来部署。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果近几年你没有接触 Web 开发，那么从简单的 Web 页面到现代 JavaScript 应用之间的转变看起来是令人生畏的，但我希望这篇文章作为一个起点来说是有用的。每个话题我都尽可能的链接了更深入的文章，所以你可以进一步了解。</p>\n<p>并且牢记，如果有时候在了解了全部可用选项之后，所有的一起都看起来还是混乱不堪；那就想想 <a href=\"https://en.wikipedia.org/wiki/KISS_principle\" target=\"_blank\" rel=\"external\">KISS 准则</a>，并且只用你认为你需要的而不是所有可用的。最终，解决问题才是最重要的，而不是使用最新的东西。</p>\n<p>你是如何学习现代 JavaScript 开发的？有没有我还没提到而你想了解的东西？我希望在评论里听到你的声音。</p>\n<h3 id=\"作者的更多文章\"><a href=\"#作者的更多文章\" class=\"headerlink\" title=\"作者的更多文章\"></a>作者的更多文章</h3><ul>\n<li><p><a href=\"https://www.sitepoint.com/scaffolding-tool-caporal-js/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">Create Your Own Yeoman-Style Scaffolding Tool with Caporal.js</a></p>\n</li>\n<li><p><a href=\"https://www.sitepoint.com/node-js-mvc-application/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">How to Build and Structure a Node.js MVC Application</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://p0.qhimg.com/t01e14535b49b558b41.png\" alt=\"A woman playing a life-size game of Operation; a metaphor for the many components of a modern JavaScript app\"></p>\n<p><em>译者能力一般，水平有限，原汁原味请移步：<a href=\"https://www.sitepoint.com/anatomy-of-a-modern-javascript-application/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<p>毫无疑问，JS 生态圈变化飞快。不仅仅新的工具与框架被快速的引入和开发，随着 ES2015（又名 ES6）的推出，JS 语言本身也经历了很大的变革。所以，已经有很多文章抱怨现在学习JavaScript 开发是多么的艰难。</p>\n<p>在这篇文章中，我将为你介绍现代 JavaScript。我们将看到这门语言最近的发展，并大概了解一下最近编写前端 Web 应用常用的工具与技术。如果你刚开始学习这门语言，或者最近几年没有碰过它并且想知道跟之前相比JavaScript发生了多大的变化，那么这篇文章再好不过。</p>\n<h2 id=\"关于-Node-js\"><a href=\"#关于-Node-js\" class=\"headerlink\" title=\"关于 Node.js\"></a>关于 Node.js</h2><p>Node.js 是一个用 JavaScript 代码编写的服务端程序运行环境。这使得全栈 JavaScript 应用成为可能，应用的前后端用同一种语言编写。虽然这篇文章的重点在客户端开发，但 Node.js 仍然扮演了一个重要的角色。</p>\n<p>Node.js 的出现对 JavaScript 生态圈产生了重大的影响，它引入了 npm 包管理工具并且推广了 CommonJS 模块规范。开发者开始发明更具创新性的工具和方法来模糊浏览器、服务器和原生应用之间的界限。</p>\n<h2 id=\"JavaScript-ES2015\"><a href=\"#JavaScript-ES2015\" class=\"headerlink\" title=\"JavaScript ES2015+\"></a>JavaScript ES2015+</h2><p>在 2005 年， 第六版 <a href=\"https://en.wikipedia.org/wiki/ECMAScript\" target=\"_blank\" rel=\"external\">ECMAScript</a>——制定 JavaScript 语言规范——以 <a href=\"http://www.ecma-international.org/ecma-262/6.0/\" target=\"_blank\" rel=\"external\">ES2015</a>（也经常被称为 ES6）的名称发布。新版本添加的大量的特性使得在构建大型 Web 应用的时候更加的轻松和灵活。但是改进的脚步并没有在 ES2015 停止，每年都将发布一个新的版本。</p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>现在 JavaScript 有两种额外的方式用来声明变量：<a href=\"https://www.sitepoint.com/how-to-declare-variables-javascript/\" target=\"_blank\" rel=\"external\"><strong>let</strong> 和 <strong>const</strong></a>。</p>\n<p><code>let</code> 是 <code>var</code> 的继任 - 虽然 <code>var</code> 依旧可用，<code>let</code> 提供了它所声明时所在块的块级作用域（而不是函数作用域），这将减少出错的几率：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">for (var i = 1; i &lt; 5; i++) &#123;</div><div class=\"line\">  console.log(i);</div><div class=\"line\">&#125;</div><div class=\"line\">// &lt;-- 打印数字 1 到 4</div><div class=\"line\">console.log(i);</div><div class=\"line\">// &lt;-- 5（变量 i 在循环外仍然存在）</div><div class=\"line\"></div><div class=\"line\">// ES2015</div><div class=\"line\">for (let j = 1; j &lt; 5; j++) &#123;</div><div class=\"line\">  console.log(j);</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(j);</div><div class=\"line\">// &lt;-- &apos;Uncaught ReferenceError: j is not defined&apos;</div></pre></td></tr></table></figure>\n<p>使用 <code>const</code> 允许你定义一个不能被重新绑定到新值的变量。对像字符串和数字的原始值来说，结果与常量类似，一旦你声明一个值，你就不能改变它了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">const name = &apos;Bill&apos;;</div><div class=\"line\">name = &apos;Steve&apos;;</div><div class=\"line\">// &lt;-- &apos;Uncaught TypeError: Assignment to constant variable.&apos;</div><div class=\"line\"></div><div class=\"line\">// Gotcha</div><div class=\"line\">const person = &#123; name: &apos;Bill&apos; &#125;;</div><div class=\"line\">person.name = &apos;Steve&apos;;</div><div class=\"line\">// person.name is now Steve. </div><div class=\"line\">// As we&apos;re not changing the object that person is bound to, JavaScript doesn&apos;t complain.</div></pre></td></tr></table></figure>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数为声明匿名函数提供了一套简洁的语法，当函数体只有一个表达式的时候，省略了 <code>function</code> 关键字和 <code>return</code> 关键字。这使得可以用更好的方式来编写函数式代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">var add = function(a, b) &#123;</div><div class=\"line\">  return a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// ES2015</div><div class=\"line\">const add = (a, b) =&gt; a + b;</div></pre></td></tr></table></figure>\n<p>箭头函数另一个重要的特性是在被定义的上下文中他们继承了 <code>this</code> 的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person()&#123;</div><div class=\"line\">  this.age = 0;</div><div class=\"line\"></div><div class=\"line\">  // ES5</div><div class=\"line\">  setInterval(function() &#123;</div><div class=\"line\">    this.age++; // |this| refers to the global object</div><div class=\"line\">  &#125;, 1000);</div><div class=\"line\"></div><div class=\"line\">  // ES2015</div><div class=\"line\">  setInterval(() =&gt; &#123;</div><div class=\"line\">    this.age++; // |this| properly refers to the person object</div><div class=\"line\">  &#125;, 1000);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Person();</div></pre></td></tr></table></figure>\n<h3 id=\"改进类的语法\"><a href=\"#改进类的语法\" class=\"headerlink\" title=\"改进类的语法\"></a>改进类的语法</h3><p>如果你喜欢面向对象编程，你可能喜欢这门语言在基于原型的基础上对类的扩展。虽然它只是语法糖，但对那些试图通过原型来效仿经典的面向对象的开发者来说，它提供了更简洁的语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Person &#123;</div><div class=\"line\">  constructor(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  greet() &#123;</div><div class=\"line\">    console.log(`Hello, my name is $&#123;this.name&#125;`);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Promises-Async-函数\"><a href=\"#Promises-Async-函数\" class=\"headerlink\" title=\"Promises / Async 函数\"></a>Promises / Async 函数</h3><p>JavaScript 的异步特性是长期以来的挑战：当处理像 Ajax 请求这种事情的时候，任何复杂一点的应用都有陷入回调地狱的风险。</p>\n<p>幸好，ES2015 用 <a href=\"https://www.sitepoint.com/deeper-dive-javascript-promises/\" target=\"_blank\" rel=\"external\">promises</a> 提供了原生支持。Promises 代表着当前不存在但随后可能会存在的值，使得对异步函数调用的管理更加可控，而不必使用多层嵌套回调。</p>\n<p>ES2017（今年推出）采用了 <a href=\"https://www.sitepoint.com/simplifying-asynchronous-coding-async-functions/\" target=\"_blank\" rel=\"external\">async 函数</a>（参考了 async/await 使得这种情况有所改善，允许用同步的方式处理异步代码）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">async function doAsyncOp () &#123;</div><div class=\"line\">  const result = await asynchronousOperation();     </div><div class=\"line\">  console.log(result);</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>ES2015 增添的另外一个突出特性是一个原生的模块规范，使得模块的定义和使用成为这门语言的一部分。之前模块的加载只能通过第三方类库的方式。在下一节，我们将深入了解一下模块。</p>\n<p>其他的特性我们不会在这里讨论，但我们已经顾及到了一些，当学习现代 JavaScript 时，可能会遇到的主要区别。在 <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"external\">Babel site</a> 的 <a href=\"https://babeljs.io/learn-es2015/\" target=\"_blank\" rel=\"external\">Learn ES2015</a> 页面上，你能得到完整的实例清单，并且你可能会找到一些有用的东西来帮你了解这门语言的最新特性。这些特性包括模板字符串，迭代器，生成器，像映射和集合新的数据结构等等。</p>\n<blockquote>\n<p>想学习 ES2015 的更多内容，关注我们的收费课程: <a href=\"https://www.sitepoint.com/premium/courses/diving-into-es2015-2924\" target=\"_blank\" rel=\"external\">Diving into ES2015</a></p>\n</blockquote>\n<h3 id=\"代码检查\"><a href=\"#代码检查\" class=\"headerlink\" title=\"代码检查\"></a>代码检查</h3><p>检查器是解析你的代码并对比是否违反一系列规则，检查语法错误，格式化和最佳实践的工具。虽然对每个人来说都推荐使用检查器，但它对新手来讲更加有用。当正确配置了代码编辑器或集成开发工具后，当正在学习一门新的语言特性时，你能得到及时的反馈来确保没有遇到语法错误。</p>\n<p>你可以<a href=\"https://www.sitepoint.com/up-and-running-with-eslint-the-pluggable-javascript-linter/\" target=\"_blank\" rel=\"external\">查看 ESLint</a>，它是最流行的之一并且支持 ES2015+。</p>\n<h2 id=\"模块化编程\"><a href=\"#模块化编程\" class=\"headerlink\" title=\"模块化编程\"></a>模块化编程</h2><p>现代 Web 应用有几千（甚至几十万）行代码。如果没有一个通过较小组件，模块化的代码和必要的代码复用进行组合的机制，在这样的代码量下工作几乎是不可能的。这就是模块的工作。</p>\n<h3 id=\"CommonJS-模块\"><a href=\"#CommonJS-模块\" class=\"headerlink\" title=\"CommonJS 模块\"></a>CommonJS 模块</h3><p>有些模块规范已经出现几年了，最流行的一个是 <a href=\"https://en.wikipedia.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a>。它是 Node.js 的默认模块规范，可以通过模块绑定的协助用在客户端，一会儿我们将讨论它。</p>\n<p>它通过一个 <code>module</code> 对象来输出来自于一个 JavaScript 文件的功能，并且通过一个 <code>require()</code> 函数来引入你所需要的功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib/math.js</div><div class=\"line\">function sum(x, y) &#123;</div><div class=\"line\">  return x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const pi = 3.141593</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  sum: sum,</div><div class=\"line\">  pi: pi</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">const math = require(&quot;lib/math&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;2π = &quot; + math.sum(math.pi, math.pi));</div></pre></td></tr></table></figure>\n<h3 id=\"ES2015-模块\"><a href=\"#ES2015-模块\" class=\"headerlink\" title=\"ES2015 模块\"></a>ES2015 模块</h3><p>ES2015 采用了在语言中定义和使用组件的方法，之前可能只用在第三方类库中。你能根据你想要的功能来编写单独的文件并且只输出可用于应用的那一部分。</p>\n<blockquote>\n<p><strong>Note</strong>: 原生浏览器对 ES2015 模块的支持还在开发中，所以当前你需要一些额外的工具的帮助才能使用它们。</p>\n</blockquote>\n<p>这有一个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib/math.js</div><div class=\"line\"></div><div class=\"line\">export function sum(x, y) &#123;</div><div class=\"line\">  return x + y;</div><div class=\"line\">&#125;</div><div class=\"line\">export let pi = 3.141593;</div></pre></td></tr></table></figure>\n<p>我们有输出一个函数和一个变量的模块。我们可以将该文件包含在另外一个文件中并且使用这些输出的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// app.js</div><div class=\"line\"></div><div class=\"line\">import * as math from &quot;lib/math&quot;;</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;2π = &quot; + math.sum(math.pi, math.pi));</div></pre></td></tr></table></figure>\n<p>或者我们也可以指定和只引入我们需要的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// otherApp.js</div><div class=\"line\"></div><div class=\"line\">import &#123;sum, pi&#125; from &quot;lib/math&quot;;</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;2π = &quot; + sum(pi, pi));</div></pre></td></tr></table></figure>\n<p>这些例子摘录于 <a href=\"https://babeljs.io/learn-es2015\" target=\"_blank\" rel=\"external\">Babel website</a>。想要深入了解，请查看 <a href=\"https://www.sitepoint.com/understanding-es6-modules/\" target=\"_blank\" rel=\"external\">Understanding ES6 Modules</a>。</p>\n<h2 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h2><p>长期以来，其他语言都有它们自己的包存储和管理工具，使得寻找和安装第三方类库与组件非常的容易。Node.js 有它自己的包管理和仓库， <a href=\"https://www.sitepoint.com/beginners-guide-node-package-manager/\" target=\"_blank\" rel=\"external\">npm</a>。虽然也有其他可用的包管理工具，但 npm 已经成为事实上的 JavaScript 包管理工具并且据说有着世界上最大的包注册量。</p>\n<p>在 <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">npm 仓库</a>，通过一个单独的 <code>npm install</code> 命令就能把想要的第三方模块轻易下载到并使用在项目中。这个包下载到本地 <code>node_modules</code> 目录，其中包含了所有的包和它们各自的依赖包。</p>\n<p>你下载的包可作为依赖被注册在项目中的 <a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json</a> 文件中，以及项目或模块（在 npm 上它本身可以当做一个包发布）的有关信息。</p>\n<p>你能为开发环境和生产环境分别定义依赖包。生产依赖包为工作需要，开发依赖包只对开发者是必需的。</p>\n<p><strong>package.json 文件示例</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;demo&quot;,</div><div class=\"line\">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class=\"line\">  &quot;description&quot;: &quot;Demo package.json&quot;,</div><div class=\"line\">  &quot;main&quot;: &quot;main.js&quot;,</div><div class=\"line\">  &quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;mkdirp&quot;: &quot;^0.5.1&quot;,</div><div class=\"line\">    &quot;underscore&quot;: &quot;^1.8.3&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;devDependencies&quot;: &#123;&#125;,</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;author&quot;: &quot;Sitepoint&quot;,</div><div class=\"line\">  &quot;license&quot;: &quot;ISC&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"构建工具\"><a href=\"#构建工具\" class=\"headerlink\" title=\"构建工具\"></a>构建工具</h2><p>我们开发现代 Web 应用时所写的代码跟将要用在生产环境中的几乎从来不一样。我们编写的最新版 JavaScript 代码可能不被浏览器所支持，我们需要大量使用那些在 <code>node_modules</code> 文件夹中第三方包以及它们各自的依赖，我们有静态分析工具或压缩工具等等。构建工具的出现帮助我们把这些转换成更有部署效率并且可以被大多数 Web 浏览器执行的代码。</p>\n<h3 id=\"模块打包\"><a href=\"#模块打包\" class=\"headerlink\" title=\"模块打包\"></a>模块打包</h3><p>当使用 ES2015/CommonJS 模块编写简洁，可复用的代码时，我们需要加载这些模块的方法（至少直到原生浏览器支持 ES2015 模块加载）。HTML 中包含一堆脚本标签对任何严肃的应用来说真不是一个可行的选择，这将很快变得笨重起来，并且所有这些分离的 HTTP 请求将会影响性能。</p>\n<p>我们可以使用 ES2015 的 <code>import</code> 命令（或CommonJS的 <code>require</code>）把我们需要的全部模块引入进来并且通过一个模块打包工具把这些模块组合成一个或多个文件（打包）。我们会把这个打包好的文件上传至服务器并且包含在 HTML 文件中。它将包含你引入的所有模块和它们必需的依赖。</p>\n<p>时下有几个热门的选择，最流行的有 <a href=\"http://webpack.js.org\" target=\"_blank\" rel=\"external\">Webpack</a>, <a href=\"http://browserify.org\" target=\"_blank\" rel=\"external\">Browserify</a> 和 <a href=\"http://rollupjs.org\" target=\"_blank\" rel=\"external\">Rollup.js</a>。你可根据你的需求，任选一个。</p>\n<blockquote>\n<p>如果你想深入学习模块打包机制和如何适应更大规模的应用开发，推荐阅读 <a href=\"https://www.sitepoint.com/javascript-modules-bundling-transpiling/\" target=\"_blank\" rel=\"external\">Understanding JavaScript Modules: Bundling &amp; Transpiling</a>。</p>\n</blockquote>\n<h3 id=\"转换编译\"><a href=\"#转换编译\" class=\"headerlink\" title=\"转换编译\"></a>转换编译</h3><p>虽然<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">现代浏览器对 ES2015 的支持很好</a>，但你的目标用户可能包括低版本浏览器和部分不支持设备的使用者。</p>\n<p>为了让现代 JavaScript 代码执行，我们需要把我们所写的代码转化成功能一样的早期版本（通常是 ES5）。执行此项任务的标准工具是 <a href=\"https://babeljs.io\" target=\"_blank\" rel=\"external\">Babel</a>；一个把你的代码转换成兼容大多数浏览器的编译器。这样你就不必等着供应商去实现所有的这一切，现在就可以使用现代 JS 的所有特性。</p>\n<p>有一些特性仅仅靠语法转换实现不了；Babel 有一个 <a href=\"http://babeljs.io/docs/usage/polyfill/\" target=\"_blank\" rel=\"external\">Polyfill</a>， 可以帮助模拟一些更复杂的特性，像 Promises。</p>\n<h3 id=\"构建系统和任务自动化\"><a href=\"#构建系统和任务自动化\" class=\"headerlink\" title=\"构建系统和任务自动化\"></a>构建系统和任务自动化</h3><p>模块打包和转换编译只是我们项目所需要的构建过程中的两步。其他的像代码压缩（为了减小文件大小），分析工具，和一些与 JavaScript 无关的任务，像图像优化和 CSS/HTML 预处理。</p>\n<p>任务管理成为一件比较费事的事情，并且我们需要一个自动化的方式来处理它，通过一些简单的命令就能执行所有的一切。最流行的两个工具是 <a href=\"http://gruntjs.com\" target=\"_blank\" rel=\"external\">Grunt.js</a> 和 <a href=\"http://gulpjs.com\" target=\"_blank\" rel=\"external\">Gulp.js</a>，它们提供了一个方法来把你的任务有序的组成一组。</p>\n<p>例如，你能通过一个像 <code>gulp build</code> 的命令执行一个代码检查器，Babel 的编译过程和 Browserify 的模块打包过程。而不必按顺序记住三个命令和相关参数，我们只执行可以自动化处理全部过程的一个命令而已。</p>\n<p>当你发现需要自己手动处理一些项目中的步骤，考虑它是否能通过任务工具自动化执行。</p>\n<blockquote>\n<p><strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/introduction-gulp-js/\" target=\"_blank\" rel=\"external\">An Introduction to Gulp.js</a></p>\n</blockquote>\n<h2 id=\"应用架构\"><a href=\"#应用架构\" class=\"headerlink\" title=\"应用架构\"></a>应用架构</h2><p>跟网站相比，Web 应用有不同的需求。例如，页面重载对一个博客来说可能可以接受，但对应用来说一定不是这样，比如 Google Docs。你的应用应该尽可能表现的像一个桌面应用，否则，可用性将大打折扣。</p>\n<p>老式的 Web 应用通常通过 Web 服务器发送几个页面来完成，当需要很多动态变化的时候，根据用户的操作通过 Ajax 替换 HTML 块来加载内容。虽然对动态网页来说，这是一个很大的进步，但它仍有其局限性；用户的每一步操作都要发送 HTML 片段或者整个页面是一种资源的浪费，尤其是从用户的角度来看。可用性仍然达不到桌面应用的响应速度。</p>\n<p>为了改善这种状况，我们发明了一种创建 Web 应用的新方法，通过客户端和服务端通信的方式呈现给用户。虽然应用对 JavaScript 需求量大大提高，结果是应用现在的表现跟原生的非常接近；没有页面重载和我们点击按钮时的长时间等待。</p>\n<h3 id=\"单页应用\"><a href=\"#单页应用\" class=\"headerlink\" title=\"单页应用\"></a>单页应用</h3><p>Web 应用最普通的高级架构被称作 <a href=\"https://en.wikipedia.org/wiki/Single-page_application\" target=\"_blank\" rel=\"external\">SPA</a>， <em>Single Page Application</em> 的简写。SPAs 是包含了应用可以正确工作所需的 JavaScript 的大块的集合。界面完全在客户端渲染，所以不需要重新加载。唯一需要变化的东西是应用中的数据，通常通过 <a href=\"https://en.wikipedia.org/wiki/Ajax_(programming\" target=\"_blank\" rel=\"external\">Ajax</a>) 的远程 API 或者其他的异步通信方法来处理。</p>\n<p>这种方式的一个缺点就是应用首次加载需要耗费很长时间。一旦它完成加载，那么，页面之间的切换将非常流畅，因为只是纯数据在客户端和服务端间传递。</p>\n<h3 id=\"通用-同构-应用\"><a href=\"#通用-同构-应用\" class=\"headerlink\" title=\"通用/同构 应用\"></a>通用/同构 应用</h3><p>虽然 SPAs 提供了很好的用户体验，但取决于你的需求，它们可能不是最佳的解决方案。尤其是你是否需要更快的初始响应时间或者搜索引擎优化。</p>\n<p>有一个相当接近的办法来解决这些问题叫 <a href=\"http://isomorphic.net/javascript\" target=\"_blank\" rel=\"external\">同构</a> (或 通用) JavaScript 应用。在这种类型的架构下，大部分代码在服务端和客户端都可以执行。你可以选择在服务端渲染用来获得更快的首屏加载速度，在这之后，用户和应用之间的交互通过客户端来渲染。因为页面最初在服务端渲染，所以搜索引擎可以正确的拿到索引。</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>现代 JavaScript 应用中，编写的代码和部署到生产环境的代码是不一样的；你只部署构建过程生成的文件。完成这项工作的流程取决于项目的大小，开发人员的数量和使用的工具与类库。</p>\n<p>例如，如果你独自编写一个小型项目，每次部署只需要执行构建过程并且上传所生成的文件到 Web 服务器。记住，你只需要上传一个包含了整个应用和依赖的，通过构建过程（转换编译，模块打包，代码压缩等）生成的单个<code>.js</code>文件。</p>\n<p>你的目录结构可以这样实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── dist</div><div class=\"line\">│   ├── app.js</div><div class=\"line\">│   └── index.html</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── src</div><div class=\"line\">│   ├── lib</div><div class=\"line\">│   │   ├── login.js</div><div class=\"line\">│   │   └── user.js</div><div class=\"line\">│   ├── app.js</div><div class=\"line\">│   └── index.html</div><div class=\"line\">├── gulpfile.js</div><div class=\"line\">├── package.json</div><div class=\"line\">└── README</div></pre></td></tr></table></figure>\n<p>使用 ES2015 编写的应用文件在<code>src</code>目录，通过 npm 安装外部包，自己的模块在<code>lib</code>目录下。</p>\n<p>然后你可以运行 Gulp，它将会执行<code>gulpfile.js</code>中的指令来构建你的项目：打包模块为一个文件（包括通过npm安装的），转换 ES2015+ 到 ES5，压缩生成的文件等。然后你能配置它生成文件到<code>dist</code>目录。</p>\n<blockquote>\n<p><strong>Note</strong>: 如果你有不需要做任何处理的文件，可以只把它们从<code>src</code>下复制到<code>dist</code>目录。你也能通过在构建系统中配置任务来完成这个过程。</p>\n</blockquote>\n<p>现在你可以只上传<code>dist</code>目录中的文件到 Web 服务器，不必担心剩下的文件，它们只对开发有用。</p>\n<h3 id=\"团队开发\"><a href=\"#团队开发\" class=\"headerlink\" title=\"团队开发\"></a>团队开发</h3><p>如果你跟其他开发者共同开发，你可能也正在使用一个共享的代码库，像 GitHub，来保存你的项目。在这种情况下，你可在提交之前执行构建过程并把生成的文件上传到 Git 仓库，稍后把它下载到生产服务器。</p>\n<p>然而，如果多名开发者一起开发时，保存生成的文件到仓库容易出错，并且你也希望保持代码整洁。幸运的是，有个更好的方法来处理这种情况：你可在构建过程中开启一个像 <a href=\"http://jenkins.io\" target=\"_blank\" rel=\"external\">Jenkins</a>, <a href=\"http://travis-ci.org\" target=\"_blank\" rel=\"external\">Travis CI</a>, <a href=\"http://circleci.com\" target=\"_blank\" rel=\"external\">CircleCI</a> 等这样的服务，这样在每次有新的提交推送到仓库之后，它都可以自动构建你的项目。开发者只关心推送更改的代码而不必每次都构建这个项目，并且自动生成的文件也和仓库保持干净，最后，你仍然有可用的生成文件用来部署。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果近几年你没有接触 Web 开发，那么从简单的 Web 页面到现代 JavaScript 应用之间的转变看起来是令人生畏的，但我希望这篇文章作为一个起点来说是有用的。每个话题我都尽可能的链接了更深入的文章，所以你可以进一步了解。</p>\n<p>并且牢记，如果有时候在了解了全部可用选项之后，所有的一起都看起来还是混乱不堪；那就想想 <a href=\"https://en.wikipedia.org/wiki/KISS_principle\" target=\"_blank\" rel=\"external\">KISS 准则</a>，并且只用你认为你需要的而不是所有可用的。最终，解决问题才是最重要的，而不是使用最新的东西。</p>\n<p>你是如何学习现代 JavaScript 开发的？有没有我还没提到而你想了解的东西？我希望在评论里听到你的声音。</p>\n<h3 id=\"作者的更多文章\"><a href=\"#作者的更多文章\" class=\"headerlink\" title=\"作者的更多文章\"></a>作者的更多文章</h3><ul>\n<li><p><a href=\"https://www.sitepoint.com/scaffolding-tool-caporal-js/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">Create Your Own Yeoman-Style Scaffolding Tool with Caporal.js</a></p>\n</li>\n<li><p><a href=\"https://www.sitepoint.com/node-js-mvc-application/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">How to Build and Structure a Node.js MVC Application</a></p>\n</li>\n</ul>\n"},{"title":"深度比较选择 Angular 还是 React","date":"2017-06-07T10:00:04.000Z","_content":"![Two knights jousting, with React and Angular logos on their shields](http://p0.qhimg.com/t01f5158142a5d7c41c.png)\n\n_译者水平有限，原汁原味请移步：[原文链接](https://www.sitepoint.com/react-vs-angular/)_\n\n应该选择 Angular 还是 React？现在JS框架两强的格局让许多开发者选择起来很纠结。无论你是一个正在思考如何入门的新手，还是一个为下个项目挑选框架的设计者，或是一个架构师为公司做长远的规划，你都有可能从学习这个主题中受益。\n\n为了节省你的时间，提前做出如下声明：在哪个框架更好这个问题上，本文不会给你一个明确的答案。但是，不想其他类似主题的文章。我不能告诉你答案，是因为一项特定的技术是否适合你的开发环境和使用场景取决于多种因素。\n\n由于不能直接回答这个问题，我们会尝试从其他的方面进行解释。我们将会通过对比 Angular（2+，不是老版本的AngularJS）和 React 来演示在两个类型相似的框架中，如何选择并调试适合自己环境的框架。你知道的，“授人以鱼不如授人以渔”。这样在以后，当这两者被更好的框架取代的时候，你能再次用同样的思路做出最优的选择。\n\n## 开始\n\n在选择任何工具之前，你都需要回答两个简单的问题：“它本身是好的工具吗？”，“它是否适合我的使用场景？”他们本身没有什么意义，所以你需要把这两个问题时刻放在脑海中。好吧，问题可能不是那么的简单，所以，我们尝试把他们分解成一些小的问题。\n\n工具本身的问题：\n\n* 它的成熟度如何以及背后支持它的是谁？\n* 它有什么样的特性？\n* 它使用什么样的架构，开发范式，和模式？\n* 围绕它的生态圈怎么样？\n\n自我反思的问题：\n\n* 我和我的同事能否轻松的学会如何使用它？\n* 它适合我的项目吗？\n* 它的开发体验怎么样？\n\n用这一系列问题，你可以评估任何工具，而我们将以 Angular 和 React 为基础进行比较。\n\n还有另外一件事我们需要说明。严格来说，拿 Angular 比较 React 不是完全公平的，因为 Angular 是一个成熟、功能完备的框架，而 React 只是一个 UI 组件库。为了弥补差距，我们谈论 React 的时候，包含了一些它经常使用的库。\n\n## 完备性\n\n作为一个熟练开发者的主要能力就是能够在旧技术和前沿技术之间保持平衡。惯例是，当采用还未成熟的新工具时，应注意一些风险：\n\n* 工具可能有缺陷并且不稳定\n* 它可能会被供应商意外的抛弃\n* 假设你需要帮助，可能没有一个大型的知识库或者成熟的社区\n\nReact 和 Angular 都有良好的出身，所以从这方面来看，我们是没必要担心的。\n\n### React\n\nReact 是由 Facebook 开发并维护的，并且用在了他们自己的产品线上， [包括 Instagram 和 WhatsApp](https://github.com/facebook/react/wiki/sites-using-react). 它已经出现大约 [3年半](https://facebook.github.io/react/blog/2013/06/05/why-react.html) 了， 所以它已经不算新了。它也是Github上[最流行的库之一](https://github.com/search?q=stars:%3E1&s=stars&type=Repositories) ，在撰写本文的时候，它大约有60,000多个 star。听起来不错。\n\n### Angular\n\nAngular（2及以上）出现的比 React 晚一点，但是如果算上之前的版本 AngularJS，情况就反过来了。它主要由 Google 维护并且用在[AdWords 和 Google Fiber](http://angularjs.blogspot.com/2015/11/how-google-uses-angular-2-with-dart.html) 产品上，很明显他们对此很有信心，显然它不会短时间内消失。\n\n## 特性\n\n像前文提到的，Angular 比 React 多些开箱即用的特性。这是有两面性的，取决于你看待它的角度。\n两者的核心功能是相似的：组件，数据绑定和平台无关的渲染\n\n### Angular\n\nAngular 提供了很多现代 web 应用所需的开箱即用的特性。一些标准特性是：\n\n* 依赖注入\n* 以 HTML 的扩展版本为基础实现模板\n* 由 @angular/router 提供路由功能\n* 利用 @angular/http 实现 Ajax 请求\n* 利用 @angular/forms 创建表单\n* CSS 组件化\n* XSS 防御\n* 单元测试组件\n\n当你自己不想花费时间去挑选类库的时候，有这么多开箱即用的特性是很方便的。 而这也意味着你被它们束缚在了一起，即使你不需要它们。并且，通常替换它们需要付出更多的努力。例如，考虑到依赖注入可以用引入来替代，我们相信使用它的小的项目相对于收益会付出更多的开销。\n\n### React\n\n使用 React，你的入门更加简单。如果我们只看 React，那么只有：\n\n* 无依赖注入\n* JSX模板，通过 JavaScript 实现的类 XML 语言\n* XSS 防御\n* 单元测试组件\n\n特性不多，未必不是好事。这意味着根据需求选择第三方类库的时候，你有更多的自由度。不好的是你不得不自己做出选择。经常与 React 一起使用的流行类库有：\n\n* 路由 [React-router](https://reacttraining.com/react-router/)\n* HTTP请求 [Fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API) (or [axios](https://github.com/mzabriskie/axios))\n* CSS 封装 [wide variety of techniques](https://github.com/MicheleBertoli/css-in-js)\n* 额外的单元测试工具 [Enzyme](https://github.com/airbnb/enzyme)\n\n我们拥有了选择类库时的自由。这让我们可以根据每个项目的特定需求来调整我们的技术栈，并且不会产生很高的学习成本。\n\n## 语言、范式和模式\n\n回顾一下两个框架的特性，让我来看一下有哪些流行的高级概念。\n\n### React\n\n当研究 React 的时候，有一些重要的概念涌上心头：JSX，Flow，Redux\n\n#### JSX\n\n许多开发者对 [JSX](https://facebook.github.io/react/docs/introducing-jsx.html) 持不同的看法：有的人喜欢它，有的人认为这是技术的巨大退步。不是遵循内容与逻辑分离的传统方法，React 决定用一种类 XML 语言把两者组合在一起放到组件中，这样你可以在 JavaScript 代码中直接编写内容标记。\n\n虽然关于标记和逻辑混合写法这个话题是有争议的，但是它有一个明显的优势：静态分析。如果你的 JSX 标记中有错误，编译器不会保持沉默，它会报出这个错误。这能帮助我们立即发现拼写错误和其他一些愚蠢的错误。\n\n#### Flow\n\n[Flow](https://flow.org/)也是由 Facebook 开发的一款 JavaScript 的类型检查工具。它能解析代码并检查一些常规的类型错误，像隐式转换或空引用。\n\n不像有着相似目的的 TypeScript，它不需要你迁移到一个新语言并且通过注释你的代码来进行类型检查。对 Flow 来说，类型注释是可选的，可以当做分析器的额外提示。如果你想用静态代码分析，但又不想重写已有的代码，对此而言 Flow 是一个不错的选择。\n\n[**扩展阅读**: [Writing Better JavaScript with Flow](https://www.sitepoint.com/writing-better-javascript-with-flow/)]\n\n#### Redux\n\n[Redux](http://redux.js.org/) 是一个清晰的管理状态变化的类库。它受 [Flux](http://facebook.github.io/flux/) 的启发，但是做了一些简化。Redux 的核心思想是用单个对象来代表应用的整个状态，该对象被叫做 reducers，通过函数实现。reducers 是纯函数，通过组件分别实现。这能更好的做到关注点与测试分离。\n\n如果你正在做一个简单的项目，引入 Redux 可能会更加复杂，但是对中大型项目来说，它是一个很好的选择。这个类库变得非常流行，也可以用在 Angular 项目中实现。\n\n所有的三项特性可以显著的增强你的开发体验：JSX 和 Flow 允许你快速的定位潜在错误，Redux 帮助你搭建一个整洁的项目架构。\n\n### Angular\n\nAngular 也有一些有趣的东西，叫 TypeScript 和 RxJS。\n\n#### TypeScript\n\n[TypeScript](https://www.typescriptlang.org/) 是一门在 JavaScript 基础上，由微软开发的新语言。他是 ES2015 的超集，并且包含了JS语言即将到来的新版本的一些特性。你能用它替代 Babel 来编写最新的 JavaScript。它也提供了一个极其强大的类型检查系统，能够通过注释和类型推理静态分析你的代码。\n\n还有一个相当微妙的优势。TypeScript 受 Java 和 .NET 的影响很深，所以如果开发者有那些语言背景，他们会发现 TypeScript 比原生 JavaScript 学起来更轻松（注意我们如何根据个人情况选择工具）。虽然 Angular 是第一个采用 TypeScript 的主要框架，但它和 React 用在一起，也是可行的。\n\n[**扩展阅读**: [An Introduction to TypeScript: Static Typing for the Web](https://www.sitepoint.com/introduction-to-typescript/)]\n\n#### RxJS\n\n[RxJS](http://reactivex.io/rxjs/) 是一个响应式的编程类库，允许对异步的操作和事件做更加灵活的处理。它是利用函数式编程把观察者模式和迭代器模式混合的组合体。RxJS 允许你把一切都当做是一个连续的流值，并且在此之上实现各种各样的操作，像映射，过滤，拆分或合并。\n\n该类库被 Angular 的 HTTP 模块采用，也在一些内部使用。当你执行一个 HTTP 请求，它返回一个 Observable 替代通常的 Promise。虽然这个库极其强大，但它也相当的复杂。想要精通它，你需要知道不同类型的 “观察者”，“主题” ，以及[上百种方法和操作符](http://reactivex.io/rxjs/manual/overview.html#operators)。呀，这看起来只是执行 HTTP 请求的一点小工作。\n\n当需要很多连续的数据流方面的工作的时候，比如 web sockets，在这种情况下 RxJS 是十分有用的，然而，这看起来仍然很复杂。无论如何，当使用 Angular 的时，你至少要对此要有基本的了解。\n\n[**扩展阅读**: [Introduction to Functional Reactive Programming with RxJS](https://www.sitepoint.com/functional-reactive-programming-rxjs/)]\n\n我们发现在提高项目的可维护性上，TypeScript 是一个强大的工具，尤其是那些代码量巨大或业务逻辑十分复杂的项目。用 TypeScript 写的代码更容易阅读与跟进。虽然 Angular 已经采用了 TypeScript，我们仍然希望更多的项目使用它。RxJS，换句话说，看起来只在特定情况下有用并且要小心使用。否则，它能给你的项目带去难以想象的复杂度。\n\n## 生态圈\n\n关于开源框架很重要的事情是围绕它而衍生出的工具数量。有时候，那些工具甚至比框架本身更有用。我们来看一下这两个框架最流行的工具和类库。\n\n### Angular\n\n#### Angular 命令行工具\n\n现代框架的流行趋势是通过一个命令行工具来帮助初始化项目，而不必亲自配置。Angular 的工具叫 [Angular CLI](https://cli.angular.io/)。它允许通过一系列的命令来生成和启动项目。所有与创建应用，启开发环境，跑测试有关的脚本都被巧妙的隐藏在叫 `node_modules` 的文件夹中。你也能在开发期间通过它生成新的代码。这使得创建新项目十分的简单。\n\n[**扩展阅读**: [The Ultimate Angular CLI Reference](https://www.sitepoint.com/ultimate-angular-cli-reference/)]\n\n#### Ionic 2\n\n[Ionic 2](http://ionic.io/2) 是一款用来开发移动端混合应用的流行框架的新版本。它提供了一个完美集成了 Angular 2 的 Cordova 容器，和一个漂亮的组件库。通过它，可以轻松的创建移动端应用。如果相比原生应用更倾向于混合应用，那么它将是一个不错的选择。\n\n#### Material design 组件\n\n如果你钟爱于 material design，你可能很高兴听到 [Material 组件库](https://material.angular.io/)可以用于 Angular。虽然当前得到了诸多支持，但其仍然处于早期阶段并且有点简陋，所以，我们希望不久的将来能有所改善。\n\n#### Angular universal\n\n[Angular universal](https://github.com/angular/universal) 是一个种子项目，被用来创建支持服务端渲染的项目。\n\n#### @ngrx/store\n\n[@ngrx/store](https://github.com/ngrx/store) 是受 Redux 启发，利用 pure reducers 基于状态突变，用于 Angular 状态管理的类库。通过集成 RxJS，可以利用变化侦测策略达到更好的性能。\n\n[**扩展阅读**: [Managing State in Angular 2 Apps with ngrx/store](https://www.sitepoint.com/managing-state-angular-2-ngrx/)]\n\n> 这里有更多的类库与工具 [the Awesome Angular list](https://github.com/AngularClass/awesome-angular).\n\n### React\n\n#### Create react app\n\n[Create-react-app](https://github.com/facebookincubator/create-react-app) 是用于快速创建 React 项目的命令行工具。跟 Angular CLI 相似，它允许生成一个新项目，启动开发服务和打包。它用 [Jest](https://www.sitepoint.com/test-react-components-jest/) 做单元测试，一款来自于 Facebook 的比较新的测试工具，本身有一些好的特性。它也支持通过环境变量做灵活的应用分析，本地环境的后端代理，Flow，和其他特性。更多内容请查看 [introduction to create-react-app](https://www.sitepoint.com/create-react-app/)\n\n#### React Native\n\n[React Native](https://facebook.github.io/react-native/) 是由 Facebook 开发的，用 React 编写移动端原生应用的平台。不像提供混合应用的 Ionic，React Native 提供真正的原生界面。它提供了一套用于绑定原生控件的标准 React 组件。也允许使用Objective-C，Java 或 Swift等原生代码编写的组件绑定到它们上。\n\n#### Material UI\n\n同样，这是用于 React 的 [material design 组件库](http://www.material-ui.com)。跟 Angular 的版本相比，这个更加成熟并且已经有很多可用的组件。\n\n#### Next.js\n\n[Next.js](https://github.com/zeit/next.js/) 是用于 React 应用在服务端渲染的框架。它提供了一个灵活的方式在服务端全部或部分渲染应用，返回结果给客户端并继续保持在浏览器中。它尝试完成一项复杂的任务，尽可能简单的创建一个通用应用，所以设置也被设计的尽可能简单。\n\n#### MobX\n\n[MobX](https://github.com/mobxjs/mobx) 是一个管理应用状态的可选库。代替在一个单一稳定的仓库中保存状态，就像 Redux 所做的，它鼓励你尽量存储所必须的最小状态并且推导出剩下的。它提供了一套修饰符来定义可见性和观察者和介绍状态的逻辑变化。\n\n[**扩展阅读**: [How to Manage Your JavaScript Application State with MobX](https://www.sitepoint.com/manage-javascript-application-state-mobx/)]\n\n#### Storybook\n\n[Storybook](https://getstorybook.io/) 是 React 的组件开发环境。它允许快速的创建单个应用来展示你的组件。在此基础上，它还提供了许多组件来记录，开发，测试和设计你的组件。在应用的其他部分，我们发现它在独立开发组件上是极其有用的。在上一篇文章中，你能学到 [关于 Storybook 的更多知识](https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/)。\n\n> 这里有更多的类库与工具 [the Awesome React list](https://github.com/enaqx/awesome-react).\n\n## 接受度，学习曲线和开发体验\n\n选择一项新技术的重要标准就是学习它有多么的容易。当然，答案取决于很多因素，比如你之前的经验，熟悉相关的概念和模式。不管怎样，给定一个框架我们仍然能评估必须学习的新东西的数量。现在，我们假设你已经了解 ES6+，构建工具和所有的这些，让我们看看你还必须要理解什么。\n\n### React\n\n使用 React 遇到的第一个障碍就是 JSX。对有些开发者而言，它写起来颇为棘手，然而，它并没有增加太多的复杂性；就像真正的  JavaScript 表达式，和特殊的类 HTML 语法。你也需要学习如何编写组件，用属性来配置和管理内部状态。你不需要学习任何新的逻辑结构与循环，因为所有的这些都是原生 JavaScript。\n\n[官方教程](https://facebook.github.io/react/docs/hello-world.html)是入门 React 的优秀资源。一旦你完成了它，那么[开始熟悉路由](https://reacttraining.com/react-router/web/guides/quick-start)。React 路由 v4 版本可能有一些复杂和特别，但无需担心。使用 Redux 需要转变范式，学会利用类库建议的方式完成已经熟悉的任务。免费视频教程 [Getting Started with Redux](https://egghead.io/courses/getting-started-with-redux) 能够帮助你快速熟悉一些核心概念。根据项目的大小和复杂度你可能不得不寻找和学习一些额外的类库，这可能是比较棘手的部分，但在这之后，一切都会顺风顺水。\n\n我们很惊喜入门 React 是如此的简单。甚至有后端经验和前端经验有限的人都能快速上手。有完善清晰的错误提示，并且提供了如何解决潜在问题的解释说明。最难的部分可能就是为所需功能寻找合适的类库，但构建和开发一个应用真的十分简单。\n\n### Angular\n\n学习 Angular 需要比 React 了解更多的概念。首先，你需要熟悉 TypeScript。对于有静态类型语言像 Java 或 .NET 使用经验的开发者来说要比 JavaScript 更好理解，但对纯 JavaScript 开发者而言，可能需要付出一些努力。\n\n框架背身就有很多主题需要学习，从基础的开始像模块、依赖注入、装饰器、组件、服务、管道、模板和指令，到高级主题像变化侦测、区块、AoT编译和 RxJS。这些此[文档](https://angular.io/docs/ts/latest/quickstart.html)中都可以找到。RxJS 本身就是很繁重的主题，在[官方网站](http://reactivex.io/)上有更多的描述。虽然从基础水平上使用它比较容易，但要使用高级主题会十分的复杂。\n\n总而言之，我们注意到使用 Angular 要比 React 难得多。眼花缭乱的新概念对新手来讲十分的困惑。即使你已经入门了，你也需要时刻注意像 RxJS 订阅管理，变化侦测性能和[未知的东西](https://angular.io/docs/ts/latest/guide/template-syntax.html)（是的，这是来自文档实际建议）。我们会经常遇到难以理解的错误信息，所以不得不经常检索它们并祈求得到一个精准的匹配。\n\n这看起来好像我们更倾向于 React，的确是。结合我们利用同样大小和复杂度的 Angular 和 React 项目，对新手开发者进行培训的经验，React 更加的顺滑。但是，像我之前所说的，这取决于多种因素，可能对你来说会有所不同。\n\n## 契合度\n\n你可能已经注意到每个框架都有它本身一系列的功能，有好的也有坏的。但在特定环境外的分析已经完成并且没能在选择哪个框架上给出答案。为了做出决定，你不得不从你自己项目的角度来考查它。这些事情需要你自己来做。\n\n现在，结合你的项目试着回答下面这些问题，顺便想想是否符合关于这两个框架你已经学到的特性。列表可能还不完全，但是应该够开始讨论了：\n\n1. 项目有多大？\n2. 要维护多久？\n3. 所有的功能都被提前定义好还是你希望灵活一些？\n4. 如果所有的特性已经明确，你需要什么功能？\n5. 应用场景和业务逻辑是否复杂？\n6. 针对哪些平台？Web端，移动端，桌面端？\n7. 是否需要服务端渲染？ SEO 重要么？\n8. 是否需要处理许多实时事件流？\n9. 你的团队有多大？\n10. 开发者的经验和他们的知识背景如何？\n11. 是否有一些你想用的现成组件库？\n\n如果你打算启动一个大项目，你可能想最小化做出不当选择的风险，首先考虑做一个概念性的验证产品。使用框架，通过简单方式，试着实现项目的一些关键特性。这通常不会花费你太多的时间，但会给你一些有价值的经验来验证关键技术需求。如果你对结果满意，你可以继续进行完整的开发。如果不满意，从长远来看其实节省了你的时间。\n\n## 一招绝？\n\n一旦你为你的项目选择了一个框架，你将会在接下来的项目中忍不住的想用同样的技术栈。不要这样。虽然保持技术栈统一是一个不错的注意，但不要总是使用同样的方法。每一个项目开始之前，花点时间再回答一遍上面的问题。可能对下个项目而言，答案就不一样了。另外，如果你想用不熟悉的技术栈做一个小项目，做吧。这些经历会带给你宝贵的经验。开放你的思维，并且从错误中不断学习。在某一点，一项特定的技术会让你自然而然的觉得正确。\n\n_此文由同行 [Jurgen Van de Moere](https://www.sitepoint.com/author/mbrown/) 和 [Joan Yin](https://www.sitepoint.com/author/jvandemoere/) 校对. 谢谢 SitePoint 所有的校对人员，你们让 SitePoint 的内容更加的优秀!_\n\n### 作者的更多文章\n*   [Automated Accessibility Checking with aXe](https://www.sitepoint.com/automated-accessibility-checking-with-axe/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n*   [React Storybook: Develop Beautiful User Interfaces with Ease](https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n                ","source":"_posts/深度比较选择-Angular-还是-React.md","raw":"---\ntitle: 深度比较选择 Angular 还是 React\ndate: 2017-06-07 18:00:04\ntags: [JavaScript, 翻译]\n---\n![Two knights jousting, with React and Angular logos on their shields](http://p0.qhimg.com/t01f5158142a5d7c41c.png)\n\n_译者水平有限，原汁原味请移步：[原文链接](https://www.sitepoint.com/react-vs-angular/)_\n\n应该选择 Angular 还是 React？现在JS框架两强的格局让许多开发者选择起来很纠结。无论你是一个正在思考如何入门的新手，还是一个为下个项目挑选框架的设计者，或是一个架构师为公司做长远的规划，你都有可能从学习这个主题中受益。\n\n为了节省你的时间，提前做出如下声明：在哪个框架更好这个问题上，本文不会给你一个明确的答案。但是，不想其他类似主题的文章。我不能告诉你答案，是因为一项特定的技术是否适合你的开发环境和使用场景取决于多种因素。\n\n由于不能直接回答这个问题，我们会尝试从其他的方面进行解释。我们将会通过对比 Angular（2+，不是老版本的AngularJS）和 React 来演示在两个类型相似的框架中，如何选择并调试适合自己环境的框架。你知道的，“授人以鱼不如授人以渔”。这样在以后，当这两者被更好的框架取代的时候，你能再次用同样的思路做出最优的选择。\n\n## 开始\n\n在选择任何工具之前，你都需要回答两个简单的问题：“它本身是好的工具吗？”，“它是否适合我的使用场景？”他们本身没有什么意义，所以你需要把这两个问题时刻放在脑海中。好吧，问题可能不是那么的简单，所以，我们尝试把他们分解成一些小的问题。\n\n工具本身的问题：\n\n* 它的成熟度如何以及背后支持它的是谁？\n* 它有什么样的特性？\n* 它使用什么样的架构，开发范式，和模式？\n* 围绕它的生态圈怎么样？\n\n自我反思的问题：\n\n* 我和我的同事能否轻松的学会如何使用它？\n* 它适合我的项目吗？\n* 它的开发体验怎么样？\n\n用这一系列问题，你可以评估任何工具，而我们将以 Angular 和 React 为基础进行比较。\n\n还有另外一件事我们需要说明。严格来说，拿 Angular 比较 React 不是完全公平的，因为 Angular 是一个成熟、功能完备的框架，而 React 只是一个 UI 组件库。为了弥补差距，我们谈论 React 的时候，包含了一些它经常使用的库。\n\n## 完备性\n\n作为一个熟练开发者的主要能力就是能够在旧技术和前沿技术之间保持平衡。惯例是，当采用还未成熟的新工具时，应注意一些风险：\n\n* 工具可能有缺陷并且不稳定\n* 它可能会被供应商意外的抛弃\n* 假设你需要帮助，可能没有一个大型的知识库或者成熟的社区\n\nReact 和 Angular 都有良好的出身，所以从这方面来看，我们是没必要担心的。\n\n### React\n\nReact 是由 Facebook 开发并维护的，并且用在了他们自己的产品线上， [包括 Instagram 和 WhatsApp](https://github.com/facebook/react/wiki/sites-using-react). 它已经出现大约 [3年半](https://facebook.github.io/react/blog/2013/06/05/why-react.html) 了， 所以它已经不算新了。它也是Github上[最流行的库之一](https://github.com/search?q=stars:%3E1&s=stars&type=Repositories) ，在撰写本文的时候，它大约有60,000多个 star。听起来不错。\n\n### Angular\n\nAngular（2及以上）出现的比 React 晚一点，但是如果算上之前的版本 AngularJS，情况就反过来了。它主要由 Google 维护并且用在[AdWords 和 Google Fiber](http://angularjs.blogspot.com/2015/11/how-google-uses-angular-2-with-dart.html) 产品上，很明显他们对此很有信心，显然它不会短时间内消失。\n\n## 特性\n\n像前文提到的，Angular 比 React 多些开箱即用的特性。这是有两面性的，取决于你看待它的角度。\n两者的核心功能是相似的：组件，数据绑定和平台无关的渲染\n\n### Angular\n\nAngular 提供了很多现代 web 应用所需的开箱即用的特性。一些标准特性是：\n\n* 依赖注入\n* 以 HTML 的扩展版本为基础实现模板\n* 由 @angular/router 提供路由功能\n* 利用 @angular/http 实现 Ajax 请求\n* 利用 @angular/forms 创建表单\n* CSS 组件化\n* XSS 防御\n* 单元测试组件\n\n当你自己不想花费时间去挑选类库的时候，有这么多开箱即用的特性是很方便的。 而这也意味着你被它们束缚在了一起，即使你不需要它们。并且，通常替换它们需要付出更多的努力。例如，考虑到依赖注入可以用引入来替代，我们相信使用它的小的项目相对于收益会付出更多的开销。\n\n### React\n\n使用 React，你的入门更加简单。如果我们只看 React，那么只有：\n\n* 无依赖注入\n* JSX模板，通过 JavaScript 实现的类 XML 语言\n* XSS 防御\n* 单元测试组件\n\n特性不多，未必不是好事。这意味着根据需求选择第三方类库的时候，你有更多的自由度。不好的是你不得不自己做出选择。经常与 React 一起使用的流行类库有：\n\n* 路由 [React-router](https://reacttraining.com/react-router/)\n* HTTP请求 [Fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API) (or [axios](https://github.com/mzabriskie/axios))\n* CSS 封装 [wide variety of techniques](https://github.com/MicheleBertoli/css-in-js)\n* 额外的单元测试工具 [Enzyme](https://github.com/airbnb/enzyme)\n\n我们拥有了选择类库时的自由。这让我们可以根据每个项目的特定需求来调整我们的技术栈，并且不会产生很高的学习成本。\n\n## 语言、范式和模式\n\n回顾一下两个框架的特性，让我来看一下有哪些流行的高级概念。\n\n### React\n\n当研究 React 的时候，有一些重要的概念涌上心头：JSX，Flow，Redux\n\n#### JSX\n\n许多开发者对 [JSX](https://facebook.github.io/react/docs/introducing-jsx.html) 持不同的看法：有的人喜欢它，有的人认为这是技术的巨大退步。不是遵循内容与逻辑分离的传统方法，React 决定用一种类 XML 语言把两者组合在一起放到组件中，这样你可以在 JavaScript 代码中直接编写内容标记。\n\n虽然关于标记和逻辑混合写法这个话题是有争议的，但是它有一个明显的优势：静态分析。如果你的 JSX 标记中有错误，编译器不会保持沉默，它会报出这个错误。这能帮助我们立即发现拼写错误和其他一些愚蠢的错误。\n\n#### Flow\n\n[Flow](https://flow.org/)也是由 Facebook 开发的一款 JavaScript 的类型检查工具。它能解析代码并检查一些常规的类型错误，像隐式转换或空引用。\n\n不像有着相似目的的 TypeScript，它不需要你迁移到一个新语言并且通过注释你的代码来进行类型检查。对 Flow 来说，类型注释是可选的，可以当做分析器的额外提示。如果你想用静态代码分析，但又不想重写已有的代码，对此而言 Flow 是一个不错的选择。\n\n[**扩展阅读**: [Writing Better JavaScript with Flow](https://www.sitepoint.com/writing-better-javascript-with-flow/)]\n\n#### Redux\n\n[Redux](http://redux.js.org/) 是一个清晰的管理状态变化的类库。它受 [Flux](http://facebook.github.io/flux/) 的启发，但是做了一些简化。Redux 的核心思想是用单个对象来代表应用的整个状态，该对象被叫做 reducers，通过函数实现。reducers 是纯函数，通过组件分别实现。这能更好的做到关注点与测试分离。\n\n如果你正在做一个简单的项目，引入 Redux 可能会更加复杂，但是对中大型项目来说，它是一个很好的选择。这个类库变得非常流行，也可以用在 Angular 项目中实现。\n\n所有的三项特性可以显著的增强你的开发体验：JSX 和 Flow 允许你快速的定位潜在错误，Redux 帮助你搭建一个整洁的项目架构。\n\n### Angular\n\nAngular 也有一些有趣的东西，叫 TypeScript 和 RxJS。\n\n#### TypeScript\n\n[TypeScript](https://www.typescriptlang.org/) 是一门在 JavaScript 基础上，由微软开发的新语言。他是 ES2015 的超集，并且包含了JS语言即将到来的新版本的一些特性。你能用它替代 Babel 来编写最新的 JavaScript。它也提供了一个极其强大的类型检查系统，能够通过注释和类型推理静态分析你的代码。\n\n还有一个相当微妙的优势。TypeScript 受 Java 和 .NET 的影响很深，所以如果开发者有那些语言背景，他们会发现 TypeScript 比原生 JavaScript 学起来更轻松（注意我们如何根据个人情况选择工具）。虽然 Angular 是第一个采用 TypeScript 的主要框架，但它和 React 用在一起，也是可行的。\n\n[**扩展阅读**: [An Introduction to TypeScript: Static Typing for the Web](https://www.sitepoint.com/introduction-to-typescript/)]\n\n#### RxJS\n\n[RxJS](http://reactivex.io/rxjs/) 是一个响应式的编程类库，允许对异步的操作和事件做更加灵活的处理。它是利用函数式编程把观察者模式和迭代器模式混合的组合体。RxJS 允许你把一切都当做是一个连续的流值，并且在此之上实现各种各样的操作，像映射，过滤，拆分或合并。\n\n该类库被 Angular 的 HTTP 模块采用，也在一些内部使用。当你执行一个 HTTP 请求，它返回一个 Observable 替代通常的 Promise。虽然这个库极其强大，但它也相当的复杂。想要精通它，你需要知道不同类型的 “观察者”，“主题” ，以及[上百种方法和操作符](http://reactivex.io/rxjs/manual/overview.html#operators)。呀，这看起来只是执行 HTTP 请求的一点小工作。\n\n当需要很多连续的数据流方面的工作的时候，比如 web sockets，在这种情况下 RxJS 是十分有用的，然而，这看起来仍然很复杂。无论如何，当使用 Angular 的时，你至少要对此要有基本的了解。\n\n[**扩展阅读**: [Introduction to Functional Reactive Programming with RxJS](https://www.sitepoint.com/functional-reactive-programming-rxjs/)]\n\n我们发现在提高项目的可维护性上，TypeScript 是一个强大的工具，尤其是那些代码量巨大或业务逻辑十分复杂的项目。用 TypeScript 写的代码更容易阅读与跟进。虽然 Angular 已经采用了 TypeScript，我们仍然希望更多的项目使用它。RxJS，换句话说，看起来只在特定情况下有用并且要小心使用。否则，它能给你的项目带去难以想象的复杂度。\n\n## 生态圈\n\n关于开源框架很重要的事情是围绕它而衍生出的工具数量。有时候，那些工具甚至比框架本身更有用。我们来看一下这两个框架最流行的工具和类库。\n\n### Angular\n\n#### Angular 命令行工具\n\n现代框架的流行趋势是通过一个命令行工具来帮助初始化项目，而不必亲自配置。Angular 的工具叫 [Angular CLI](https://cli.angular.io/)。它允许通过一系列的命令来生成和启动项目。所有与创建应用，启开发环境，跑测试有关的脚本都被巧妙的隐藏在叫 `node_modules` 的文件夹中。你也能在开发期间通过它生成新的代码。这使得创建新项目十分的简单。\n\n[**扩展阅读**: [The Ultimate Angular CLI Reference](https://www.sitepoint.com/ultimate-angular-cli-reference/)]\n\n#### Ionic 2\n\n[Ionic 2](http://ionic.io/2) 是一款用来开发移动端混合应用的流行框架的新版本。它提供了一个完美集成了 Angular 2 的 Cordova 容器，和一个漂亮的组件库。通过它，可以轻松的创建移动端应用。如果相比原生应用更倾向于混合应用，那么它将是一个不错的选择。\n\n#### Material design 组件\n\n如果你钟爱于 material design，你可能很高兴听到 [Material 组件库](https://material.angular.io/)可以用于 Angular。虽然当前得到了诸多支持，但其仍然处于早期阶段并且有点简陋，所以，我们希望不久的将来能有所改善。\n\n#### Angular universal\n\n[Angular universal](https://github.com/angular/universal) 是一个种子项目，被用来创建支持服务端渲染的项目。\n\n#### @ngrx/store\n\n[@ngrx/store](https://github.com/ngrx/store) 是受 Redux 启发，利用 pure reducers 基于状态突变，用于 Angular 状态管理的类库。通过集成 RxJS，可以利用变化侦测策略达到更好的性能。\n\n[**扩展阅读**: [Managing State in Angular 2 Apps with ngrx/store](https://www.sitepoint.com/managing-state-angular-2-ngrx/)]\n\n> 这里有更多的类库与工具 [the Awesome Angular list](https://github.com/AngularClass/awesome-angular).\n\n### React\n\n#### Create react app\n\n[Create-react-app](https://github.com/facebookincubator/create-react-app) 是用于快速创建 React 项目的命令行工具。跟 Angular CLI 相似，它允许生成一个新项目，启动开发服务和打包。它用 [Jest](https://www.sitepoint.com/test-react-components-jest/) 做单元测试，一款来自于 Facebook 的比较新的测试工具，本身有一些好的特性。它也支持通过环境变量做灵活的应用分析，本地环境的后端代理，Flow，和其他特性。更多内容请查看 [introduction to create-react-app](https://www.sitepoint.com/create-react-app/)\n\n#### React Native\n\n[React Native](https://facebook.github.io/react-native/) 是由 Facebook 开发的，用 React 编写移动端原生应用的平台。不像提供混合应用的 Ionic，React Native 提供真正的原生界面。它提供了一套用于绑定原生控件的标准 React 组件。也允许使用Objective-C，Java 或 Swift等原生代码编写的组件绑定到它们上。\n\n#### Material UI\n\n同样，这是用于 React 的 [material design 组件库](http://www.material-ui.com)。跟 Angular 的版本相比，这个更加成熟并且已经有很多可用的组件。\n\n#### Next.js\n\n[Next.js](https://github.com/zeit/next.js/) 是用于 React 应用在服务端渲染的框架。它提供了一个灵活的方式在服务端全部或部分渲染应用，返回结果给客户端并继续保持在浏览器中。它尝试完成一项复杂的任务，尽可能简单的创建一个通用应用，所以设置也被设计的尽可能简单。\n\n#### MobX\n\n[MobX](https://github.com/mobxjs/mobx) 是一个管理应用状态的可选库。代替在一个单一稳定的仓库中保存状态，就像 Redux 所做的，它鼓励你尽量存储所必须的最小状态并且推导出剩下的。它提供了一套修饰符来定义可见性和观察者和介绍状态的逻辑变化。\n\n[**扩展阅读**: [How to Manage Your JavaScript Application State with MobX](https://www.sitepoint.com/manage-javascript-application-state-mobx/)]\n\n#### Storybook\n\n[Storybook](https://getstorybook.io/) 是 React 的组件开发环境。它允许快速的创建单个应用来展示你的组件。在此基础上，它还提供了许多组件来记录，开发，测试和设计你的组件。在应用的其他部分，我们发现它在独立开发组件上是极其有用的。在上一篇文章中，你能学到 [关于 Storybook 的更多知识](https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/)。\n\n> 这里有更多的类库与工具 [the Awesome React list](https://github.com/enaqx/awesome-react).\n\n## 接受度，学习曲线和开发体验\n\n选择一项新技术的重要标准就是学习它有多么的容易。当然，答案取决于很多因素，比如你之前的经验，熟悉相关的概念和模式。不管怎样，给定一个框架我们仍然能评估必须学习的新东西的数量。现在，我们假设你已经了解 ES6+，构建工具和所有的这些，让我们看看你还必须要理解什么。\n\n### React\n\n使用 React 遇到的第一个障碍就是 JSX。对有些开发者而言，它写起来颇为棘手，然而，它并没有增加太多的复杂性；就像真正的  JavaScript 表达式，和特殊的类 HTML 语法。你也需要学习如何编写组件，用属性来配置和管理内部状态。你不需要学习任何新的逻辑结构与循环，因为所有的这些都是原生 JavaScript。\n\n[官方教程](https://facebook.github.io/react/docs/hello-world.html)是入门 React 的优秀资源。一旦你完成了它，那么[开始熟悉路由](https://reacttraining.com/react-router/web/guides/quick-start)。React 路由 v4 版本可能有一些复杂和特别，但无需担心。使用 Redux 需要转变范式，学会利用类库建议的方式完成已经熟悉的任务。免费视频教程 [Getting Started with Redux](https://egghead.io/courses/getting-started-with-redux) 能够帮助你快速熟悉一些核心概念。根据项目的大小和复杂度你可能不得不寻找和学习一些额外的类库，这可能是比较棘手的部分，但在这之后，一切都会顺风顺水。\n\n我们很惊喜入门 React 是如此的简单。甚至有后端经验和前端经验有限的人都能快速上手。有完善清晰的错误提示，并且提供了如何解决潜在问题的解释说明。最难的部分可能就是为所需功能寻找合适的类库，但构建和开发一个应用真的十分简单。\n\n### Angular\n\n学习 Angular 需要比 React 了解更多的概念。首先，你需要熟悉 TypeScript。对于有静态类型语言像 Java 或 .NET 使用经验的开发者来说要比 JavaScript 更好理解，但对纯 JavaScript 开发者而言，可能需要付出一些努力。\n\n框架背身就有很多主题需要学习，从基础的开始像模块、依赖注入、装饰器、组件、服务、管道、模板和指令，到高级主题像变化侦测、区块、AoT编译和 RxJS。这些此[文档](https://angular.io/docs/ts/latest/quickstart.html)中都可以找到。RxJS 本身就是很繁重的主题，在[官方网站](http://reactivex.io/)上有更多的描述。虽然从基础水平上使用它比较容易，但要使用高级主题会十分的复杂。\n\n总而言之，我们注意到使用 Angular 要比 React 难得多。眼花缭乱的新概念对新手来讲十分的困惑。即使你已经入门了，你也需要时刻注意像 RxJS 订阅管理，变化侦测性能和[未知的东西](https://angular.io/docs/ts/latest/guide/template-syntax.html)（是的，这是来自文档实际建议）。我们会经常遇到难以理解的错误信息，所以不得不经常检索它们并祈求得到一个精准的匹配。\n\n这看起来好像我们更倾向于 React，的确是。结合我们利用同样大小和复杂度的 Angular 和 React 项目，对新手开发者进行培训的经验，React 更加的顺滑。但是，像我之前所说的，这取决于多种因素，可能对你来说会有所不同。\n\n## 契合度\n\n你可能已经注意到每个框架都有它本身一系列的功能，有好的也有坏的。但在特定环境外的分析已经完成并且没能在选择哪个框架上给出答案。为了做出决定，你不得不从你自己项目的角度来考查它。这些事情需要你自己来做。\n\n现在，结合你的项目试着回答下面这些问题，顺便想想是否符合关于这两个框架你已经学到的特性。列表可能还不完全，但是应该够开始讨论了：\n\n1. 项目有多大？\n2. 要维护多久？\n3. 所有的功能都被提前定义好还是你希望灵活一些？\n4. 如果所有的特性已经明确，你需要什么功能？\n5. 应用场景和业务逻辑是否复杂？\n6. 针对哪些平台？Web端，移动端，桌面端？\n7. 是否需要服务端渲染？ SEO 重要么？\n8. 是否需要处理许多实时事件流？\n9. 你的团队有多大？\n10. 开发者的经验和他们的知识背景如何？\n11. 是否有一些你想用的现成组件库？\n\n如果你打算启动一个大项目，你可能想最小化做出不当选择的风险，首先考虑做一个概念性的验证产品。使用框架，通过简单方式，试着实现项目的一些关键特性。这通常不会花费你太多的时间，但会给你一些有价值的经验来验证关键技术需求。如果你对结果满意，你可以继续进行完整的开发。如果不满意，从长远来看其实节省了你的时间。\n\n## 一招绝？\n\n一旦你为你的项目选择了一个框架，你将会在接下来的项目中忍不住的想用同样的技术栈。不要这样。虽然保持技术栈统一是一个不错的注意，但不要总是使用同样的方法。每一个项目开始之前，花点时间再回答一遍上面的问题。可能对下个项目而言，答案就不一样了。另外，如果你想用不熟悉的技术栈做一个小项目，做吧。这些经历会带给你宝贵的经验。开放你的思维，并且从错误中不断学习。在某一点，一项特定的技术会让你自然而然的觉得正确。\n\n_此文由同行 [Jurgen Van de Moere](https://www.sitepoint.com/author/mbrown/) 和 [Joan Yin](https://www.sitepoint.com/author/jvandemoere/) 校对. 谢谢 SitePoint 所有的校对人员，你们让 SitePoint 的内容更加的优秀!_\n\n### 作者的更多文章\n*   [Automated Accessibility Checking with aXe](https://www.sitepoint.com/automated-accessibility-checking-with-axe/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n*   [React Storybook: Develop Beautiful User Interfaces with Ease](https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/?utm_source=sitepoint&utm_medium=relatedinline&utm_term=&utm_campaign=relatedauthor)\n                ","slug":"深度比较选择-Angular-还是-React","published":1,"updated":"2017-06-25T10:36:20.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4cl7dhw000h98vk3zkg9pmq","content":"<p><img src=\"http://p0.qhimg.com/t01f5158142a5d7c41c.png\" alt=\"Two knights jousting, with React and Angular logos on their shields\"></p>\n<p><em>译者水平有限，原汁原味请移步：<a href=\"https://www.sitepoint.com/react-vs-angular/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<p>应该选择 Angular 还是 React？现在JS框架两强的格局让许多开发者选择起来很纠结。无论你是一个正在思考如何入门的新手，还是一个为下个项目挑选框架的设计者，或是一个架构师为公司做长远的规划，你都有可能从学习这个主题中受益。</p>\n<p>为了节省你的时间，提前做出如下声明：在哪个框架更好这个问题上，本文不会给你一个明确的答案。但是，不想其他类似主题的文章。我不能告诉你答案，是因为一项特定的技术是否适合你的开发环境和使用场景取决于多种因素。</p>\n<p>由于不能直接回答这个问题，我们会尝试从其他的方面进行解释。我们将会通过对比 Angular（2+，不是老版本的AngularJS）和 React 来演示在两个类型相似的框架中，如何选择并调试适合自己环境的框架。你知道的，“授人以鱼不如授人以渔”。这样在以后，当这两者被更好的框架取代的时候，你能再次用同样的思路做出最优的选择。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>在选择任何工具之前，你都需要回答两个简单的问题：“它本身是好的工具吗？”，“它是否适合我的使用场景？”他们本身没有什么意义，所以你需要把这两个问题时刻放在脑海中。好吧，问题可能不是那么的简单，所以，我们尝试把他们分解成一些小的问题。</p>\n<p>工具本身的问题：</p>\n<ul>\n<li>它的成熟度如何以及背后支持它的是谁？</li>\n<li>它有什么样的特性？</li>\n<li>它使用什么样的架构，开发范式，和模式？</li>\n<li>围绕它的生态圈怎么样？</li>\n</ul>\n<p>自我反思的问题：</p>\n<ul>\n<li>我和我的同事能否轻松的学会如何使用它？</li>\n<li>它适合我的项目吗？</li>\n<li>它的开发体验怎么样？</li>\n</ul>\n<p>用这一系列问题，你可以评估任何工具，而我们将以 Angular 和 React 为基础进行比较。</p>\n<p>还有另外一件事我们需要说明。严格来说，拿 Angular 比较 React 不是完全公平的，因为 Angular 是一个成熟、功能完备的框架，而 React 只是一个 UI 组件库。为了弥补差距，我们谈论 React 的时候，包含了一些它经常使用的库。</p>\n<h2 id=\"完备性\"><a href=\"#完备性\" class=\"headerlink\" title=\"完备性\"></a>完备性</h2><p>作为一个熟练开发者的主要能力就是能够在旧技术和前沿技术之间保持平衡。惯例是，当采用还未成熟的新工具时，应注意一些风险：</p>\n<ul>\n<li>工具可能有缺陷并且不稳定</li>\n<li>它可能会被供应商意外的抛弃</li>\n<li>假设你需要帮助，可能没有一个大型的知识库或者成熟的社区</li>\n</ul>\n<p>React 和 Angular 都有良好的出身，所以从这方面来看，我们是没必要担心的。</p>\n<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><p>React 是由 Facebook 开发并维护的，并且用在了他们自己的产品线上， <a href=\"https://github.com/facebook/react/wiki/sites-using-react\" target=\"_blank\" rel=\"external\">包括 Instagram 和 WhatsApp</a>. 它已经出现大约 <a href=\"https://facebook.github.io/react/blog/2013/06/05/why-react.html\" target=\"_blank\" rel=\"external\">3年半</a> 了， 所以它已经不算新了。它也是Github上<a href=\"https://github.com/search?q=stars:%3E1&amp;s=stars&amp;type=Repositories\" target=\"_blank\" rel=\"external\">最流行的库之一</a> ，在撰写本文的时候，它大约有60,000多个 star。听起来不错。</p>\n<h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular（2及以上）出现的比 React 晚一点，但是如果算上之前的版本 AngularJS，情况就反过来了。它主要由 Google 维护并且用在<a href=\"http://angularjs.blogspot.com/2015/11/how-google-uses-angular-2-with-dart.html\" target=\"_blank\" rel=\"external\">AdWords 和 Google Fiber</a> 产品上，很明显他们对此很有信心，显然它不会短时间内消失。</p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><p>像前文提到的，Angular 比 React 多些开箱即用的特性。这是有两面性的，取决于你看待它的角度。<br>两者的核心功能是相似的：组件，数据绑定和平台无关的渲染</p>\n<h3 id=\"Angular-1\"><a href=\"#Angular-1\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 提供了很多现代 web 应用所需的开箱即用的特性。一些标准特性是：</p>\n<ul>\n<li>依赖注入</li>\n<li>以 HTML 的扩展版本为基础实现模板</li>\n<li>由 @angular/router 提供路由功能</li>\n<li>利用 @angular/http 实现 Ajax 请求</li>\n<li>利用 @angular/forms 创建表单</li>\n<li>CSS 组件化</li>\n<li>XSS 防御</li>\n<li>单元测试组件</li>\n</ul>\n<p>当你自己不想花费时间去挑选类库的时候，有这么多开箱即用的特性是很方便的。 而这也意味着你被它们束缚在了一起，即使你不需要它们。并且，通常替换它们需要付出更多的努力。例如，考虑到依赖注入可以用引入来替代，我们相信使用它的小的项目相对于收益会付出更多的开销。</p>\n<h3 id=\"React-1\"><a href=\"#React-1\" class=\"headerlink\" title=\"React\"></a>React</h3><p>使用 React，你的入门更加简单。如果我们只看 React，那么只有：</p>\n<ul>\n<li>无依赖注入</li>\n<li>JSX模板，通过 JavaScript 实现的类 XML 语言</li>\n<li>XSS 防御</li>\n<li>单元测试组件</li>\n</ul>\n<p>特性不多，未必不是好事。这意味着根据需求选择第三方类库的时候，你有更多的自由度。不好的是你不得不自己做出选择。经常与 React 一起使用的流行类库有：</p>\n<ul>\n<li>路由 <a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"external\">React-router</a></li>\n<li>HTTP请求 <a href=\"https://developer.mozilla.org/en/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"external\">Fetch</a> (or <a href=\"https://github.com/mzabriskie/axios\" target=\"_blank\" rel=\"external\">axios</a>)</li>\n<li>CSS 封装 <a href=\"https://github.com/MicheleBertoli/css-in-js\" target=\"_blank\" rel=\"external\">wide variety of techniques</a></li>\n<li>额外的单元测试工具 <a href=\"https://github.com/airbnb/enzyme\" target=\"_blank\" rel=\"external\">Enzyme</a></li>\n</ul>\n<p>我们拥有了选择类库时的自由。这让我们可以根据每个项目的特定需求来调整我们的技术栈，并且不会产生很高的学习成本。</p>\n<h2 id=\"语言、范式和模式\"><a href=\"#语言、范式和模式\" class=\"headerlink\" title=\"语言、范式和模式\"></a>语言、范式和模式</h2><p>回顾一下两个框架的特性，让我来看一下有哪些流行的高级概念。</p>\n<h3 id=\"React-2\"><a href=\"#React-2\" class=\"headerlink\" title=\"React\"></a>React</h3><p>当研究 React 的时候，有一些重要的概念涌上心头：JSX，Flow，Redux</p>\n<h4 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h4><p>许多开发者对 <a href=\"https://facebook.github.io/react/docs/introducing-jsx.html\" target=\"_blank\" rel=\"external\">JSX</a> 持不同的看法：有的人喜欢它，有的人认为这是技术的巨大退步。不是遵循内容与逻辑分离的传统方法，React 决定用一种类 XML 语言把两者组合在一起放到组件中，这样你可以在 JavaScript 代码中直接编写内容标记。</p>\n<p>虽然关于标记和逻辑混合写法这个话题是有争议的，但是它有一个明显的优势：静态分析。如果你的 JSX 标记中有错误，编译器不会保持沉默，它会报出这个错误。这能帮助我们立即发现拼写错误和其他一些愚蠢的错误。</p>\n<h4 id=\"Flow\"><a href=\"#Flow\" class=\"headerlink\" title=\"Flow\"></a>Flow</h4><p><a href=\"https://flow.org/\" target=\"_blank\" rel=\"external\">Flow</a>也是由 Facebook 开发的一款 JavaScript 的类型检查工具。它能解析代码并检查一些常规的类型错误，像隐式转换或空引用。</p>\n<p>不像有着相似目的的 TypeScript，它不需要你迁移到一个新语言并且通过注释你的代码来进行类型检查。对 Flow 来说，类型注释是可选的，可以当做分析器的额外提示。如果你想用静态代码分析，但又不想重写已有的代码，对此而言 Flow 是一个不错的选择。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/writing-better-javascript-with-flow/\" target=\"_blank\" rel=\"external\">Writing Better JavaScript with Flow</a>]</p>\n<h4 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h4><p><a href=\"http://redux.js.org/\" target=\"_blank\" rel=\"external\">Redux</a> 是一个清晰的管理状态变化的类库。它受 <a href=\"http://facebook.github.io/flux/\" target=\"_blank\" rel=\"external\">Flux</a> 的启发，但是做了一些简化。Redux 的核心思想是用单个对象来代表应用的整个状态，该对象被叫做 reducers，通过函数实现。reducers 是纯函数，通过组件分别实现。这能更好的做到关注点与测试分离。</p>\n<p>如果你正在做一个简单的项目，引入 Redux 可能会更加复杂，但是对中大型项目来说，它是一个很好的选择。这个类库变得非常流行，也可以用在 Angular 项目中实现。</p>\n<p>所有的三项特性可以显著的增强你的开发体验：JSX 和 Flow 允许你快速的定位潜在错误，Redux 帮助你搭建一个整洁的项目架构。</p>\n<h3 id=\"Angular-2\"><a href=\"#Angular-2\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 也有一些有趣的东西，叫 TypeScript 和 RxJS。</p>\n<h4 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h4><p><a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"external\">TypeScript</a> 是一门在 JavaScript 基础上，由微软开发的新语言。他是 ES2015 的超集，并且包含了JS语言即将到来的新版本的一些特性。你能用它替代 Babel 来编写最新的 JavaScript。它也提供了一个极其强大的类型检查系统，能够通过注释和类型推理静态分析你的代码。</p>\n<p>还有一个相当微妙的优势。TypeScript 受 Java 和 .NET 的影响很深，所以如果开发者有那些语言背景，他们会发现 TypeScript 比原生 JavaScript 学起来更轻松（注意我们如何根据个人情况选择工具）。虽然 Angular 是第一个采用 TypeScript 的主要框架，但它和 React 用在一起，也是可行的。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/introduction-to-typescript/\" target=\"_blank\" rel=\"external\">An Introduction to TypeScript: Static Typing for the Web</a>]</p>\n<h4 id=\"RxJS\"><a href=\"#RxJS\" class=\"headerlink\" title=\"RxJS\"></a>RxJS</h4><p><a href=\"http://reactivex.io/rxjs/\" target=\"_blank\" rel=\"external\">RxJS</a> 是一个响应式的编程类库，允许对异步的操作和事件做更加灵活的处理。它是利用函数式编程把观察者模式和迭代器模式混合的组合体。RxJS 允许你把一切都当做是一个连续的流值，并且在此之上实现各种各样的操作，像映射，过滤，拆分或合并。</p>\n<p>该类库被 Angular 的 HTTP 模块采用，也在一些内部使用。当你执行一个 HTTP 请求，它返回一个 Observable 替代通常的 Promise。虽然这个库极其强大，但它也相当的复杂。想要精通它，你需要知道不同类型的 “观察者”，“主题” ，以及<a href=\"http://reactivex.io/rxjs/manual/overview.html#operators\" target=\"_blank\" rel=\"external\">上百种方法和操作符</a>。呀，这看起来只是执行 HTTP 请求的一点小工作。</p>\n<p>当需要很多连续的数据流方面的工作的时候，比如 web sockets，在这种情况下 RxJS 是十分有用的，然而，这看起来仍然很复杂。无论如何，当使用 Angular 的时，你至少要对此要有基本的了解。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/functional-reactive-programming-rxjs/\" target=\"_blank\" rel=\"external\">Introduction to Functional Reactive Programming with RxJS</a>]</p>\n<p>我们发现在提高项目的可维护性上，TypeScript 是一个强大的工具，尤其是那些代码量巨大或业务逻辑十分复杂的项目。用 TypeScript 写的代码更容易阅读与跟进。虽然 Angular 已经采用了 TypeScript，我们仍然希望更多的项目使用它。RxJS，换句话说，看起来只在特定情况下有用并且要小心使用。否则，它能给你的项目带去难以想象的复杂度。</p>\n<h2 id=\"生态圈\"><a href=\"#生态圈\" class=\"headerlink\" title=\"生态圈\"></a>生态圈</h2><p>关于开源框架很重要的事情是围绕它而衍生出的工具数量。有时候，那些工具甚至比框架本身更有用。我们来看一下这两个框架最流行的工具和类库。</p>\n<h3 id=\"Angular-3\"><a href=\"#Angular-3\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><h4 id=\"Angular-命令行工具\"><a href=\"#Angular-命令行工具\" class=\"headerlink\" title=\"Angular 命令行工具\"></a>Angular 命令行工具</h4><p>现代框架的流行趋势是通过一个命令行工具来帮助初始化项目，而不必亲自配置。Angular 的工具叫 <a href=\"https://cli.angular.io/\" target=\"_blank\" rel=\"external\">Angular CLI</a>。它允许通过一系列的命令来生成和启动项目。所有与创建应用，启开发环境，跑测试有关的脚本都被巧妙的隐藏在叫 <code>node_modules</code> 的文件夹中。你也能在开发期间通过它生成新的代码。这使得创建新项目十分的简单。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/ultimate-angular-cli-reference/\" target=\"_blank\" rel=\"external\">The Ultimate Angular CLI Reference</a>]</p>\n<h4 id=\"Ionic-2\"><a href=\"#Ionic-2\" class=\"headerlink\" title=\"Ionic 2\"></a>Ionic 2</h4><p><a href=\"http://ionic.io/2\" target=\"_blank\" rel=\"external\">Ionic 2</a> 是一款用来开发移动端混合应用的流行框架的新版本。它提供了一个完美集成了 Angular 2 的 Cordova 容器，和一个漂亮的组件库。通过它，可以轻松的创建移动端应用。如果相比原生应用更倾向于混合应用，那么它将是一个不错的选择。</p>\n<h4 id=\"Material-design-组件\"><a href=\"#Material-design-组件\" class=\"headerlink\" title=\"Material design 组件\"></a>Material design 组件</h4><p>如果你钟爱于 material design，你可能很高兴听到 <a href=\"https://material.angular.io/\" target=\"_blank\" rel=\"external\">Material 组件库</a>可以用于 Angular。虽然当前得到了诸多支持，但其仍然处于早期阶段并且有点简陋，所以，我们希望不久的将来能有所改善。</p>\n<h4 id=\"Angular-universal\"><a href=\"#Angular-universal\" class=\"headerlink\" title=\"Angular universal\"></a>Angular universal</h4><p><a href=\"https://github.com/angular/universal\" target=\"_blank\" rel=\"external\">Angular universal</a> 是一个种子项目，被用来创建支持服务端渲染的项目。</p>\n<h4 id=\"ngrx-store\"><a href=\"#ngrx-store\" class=\"headerlink\" title=\"@ngrx/store\"></a>@ngrx/store</h4><p><a href=\"https://github.com/ngrx/store\" target=\"_blank\" rel=\"external\">@ngrx/store</a> 是受 Redux 启发，利用 pure reducers 基于状态突变，用于 Angular 状态管理的类库。通过集成 RxJS，可以利用变化侦测策略达到更好的性能。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/managing-state-angular-2-ngrx/\" target=\"_blank\" rel=\"external\">Managing State in Angular 2 Apps with ngrx/store</a>]</p>\n<blockquote>\n<p>这里有更多的类库与工具 <a href=\"https://github.com/AngularClass/awesome-angular\" target=\"_blank\" rel=\"external\">the Awesome Angular list</a>.</p>\n</blockquote>\n<h3 id=\"React-3\"><a href=\"#React-3\" class=\"headerlink\" title=\"React\"></a>React</h3><h4 id=\"Create-react-app\"><a href=\"#Create-react-app\" class=\"headerlink\" title=\"Create react app\"></a>Create react app</h4><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"external\">Create-react-app</a> 是用于快速创建 React 项目的命令行工具。跟 Angular CLI 相似，它允许生成一个新项目，启动开发服务和打包。它用 <a href=\"https://www.sitepoint.com/test-react-components-jest/\" target=\"_blank\" rel=\"external\">Jest</a> 做单元测试，一款来自于 Facebook 的比较新的测试工具，本身有一些好的特性。它也支持通过环境变量做灵活的应用分析，本地环境的后端代理，Flow，和其他特性。更多内容请查看 <a href=\"https://www.sitepoint.com/create-react-app/\" target=\"_blank\" rel=\"external\">introduction to create-react-app</a></p>\n<h4 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h4><p><a href=\"https://facebook.github.io/react-native/\" target=\"_blank\" rel=\"external\">React Native</a> 是由 Facebook 开发的，用 React 编写移动端原生应用的平台。不像提供混合应用的 Ionic，React Native 提供真正的原生界面。它提供了一套用于绑定原生控件的标准 React 组件。也允许使用Objective-C，Java 或 Swift等原生代码编写的组件绑定到它们上。</p>\n<h4 id=\"Material-UI\"><a href=\"#Material-UI\" class=\"headerlink\" title=\"Material UI\"></a>Material UI</h4><p>同样，这是用于 React 的 <a href=\"http://www.material-ui.com\" target=\"_blank\" rel=\"external\">material design 组件库</a>。跟 Angular 的版本相比，这个更加成熟并且已经有很多可用的组件。</p>\n<h4 id=\"Next-js\"><a href=\"#Next-js\" class=\"headerlink\" title=\"Next.js\"></a>Next.js</h4><p><a href=\"https://github.com/zeit/next.js/\" target=\"_blank\" rel=\"external\">Next.js</a> 是用于 React 应用在服务端渲染的框架。它提供了一个灵活的方式在服务端全部或部分渲染应用，返回结果给客户端并继续保持在浏览器中。它尝试完成一项复杂的任务，尽可能简单的创建一个通用应用，所以设置也被设计的尽可能简单。</p>\n<h4 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h4><p><a href=\"https://github.com/mobxjs/mobx\" target=\"_blank\" rel=\"external\">MobX</a> 是一个管理应用状态的可选库。代替在一个单一稳定的仓库中保存状态，就像 Redux 所做的，它鼓励你尽量存储所必须的最小状态并且推导出剩下的。它提供了一套修饰符来定义可见性和观察者和介绍状态的逻辑变化。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/manage-javascript-application-state-mobx/\" target=\"_blank\" rel=\"external\">How to Manage Your JavaScript Application State with MobX</a>]</p>\n<h4 id=\"Storybook\"><a href=\"#Storybook\" class=\"headerlink\" title=\"Storybook\"></a>Storybook</h4><p><a href=\"https://getstorybook.io/\" target=\"_blank\" rel=\"external\">Storybook</a> 是 React 的组件开发环境。它允许快速的创建单个应用来展示你的组件。在此基础上，它还提供了许多组件来记录，开发，测试和设计你的组件。在应用的其他部分，我们发现它在独立开发组件上是极其有用的。在上一篇文章中，你能学到 <a href=\"https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/\" target=\"_blank\" rel=\"external\">关于 Storybook 的更多知识</a>。</p>\n<blockquote>\n<p>这里有更多的类库与工具 <a href=\"https://github.com/enaqx/awesome-react\" target=\"_blank\" rel=\"external\">the Awesome React list</a>.</p>\n</blockquote>\n<h2 id=\"接受度，学习曲线和开发体验\"><a href=\"#接受度，学习曲线和开发体验\" class=\"headerlink\" title=\"接受度，学习曲线和开发体验\"></a>接受度，学习曲线和开发体验</h2><p>选择一项新技术的重要标准就是学习它有多么的容易。当然，答案取决于很多因素，比如你之前的经验，熟悉相关的概念和模式。不管怎样，给定一个框架我们仍然能评估必须学习的新东西的数量。现在，我们假设你已经了解 ES6+，构建工具和所有的这些，让我们看看你还必须要理解什么。</p>\n<h3 id=\"React-4\"><a href=\"#React-4\" class=\"headerlink\" title=\"React\"></a>React</h3><p>使用 React 遇到的第一个障碍就是 JSX。对有些开发者而言，它写起来颇为棘手，然而，它并没有增加太多的复杂性；就像真正的  JavaScript 表达式，和特殊的类 HTML 语法。你也需要学习如何编写组件，用属性来配置和管理内部状态。你不需要学习任何新的逻辑结构与循环，因为所有的这些都是原生 JavaScript。</p>\n<p><a href=\"https://facebook.github.io/react/docs/hello-world.html\" target=\"_blank\" rel=\"external\">官方教程</a>是入门 React 的优秀资源。一旦你完成了它，那么<a href=\"https://reacttraining.com/react-router/web/guides/quick-start\" target=\"_blank\" rel=\"external\">开始熟悉路由</a>。React 路由 v4 版本可能有一些复杂和特别，但无需担心。使用 Redux 需要转变范式，学会利用类库建议的方式完成已经熟悉的任务。免费视频教程 <a href=\"https://egghead.io/courses/getting-started-with-redux\" target=\"_blank\" rel=\"external\">Getting Started with Redux</a> 能够帮助你快速熟悉一些核心概念。根据项目的大小和复杂度你可能不得不寻找和学习一些额外的类库，这可能是比较棘手的部分，但在这之后，一切都会顺风顺水。</p>\n<p>我们很惊喜入门 React 是如此的简单。甚至有后端经验和前端经验有限的人都能快速上手。有完善清晰的错误提示，并且提供了如何解决潜在问题的解释说明。最难的部分可能就是为所需功能寻找合适的类库，但构建和开发一个应用真的十分简单。</p>\n<h3 id=\"Angular-4\"><a href=\"#Angular-4\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>学习 Angular 需要比 React 了解更多的概念。首先，你需要熟悉 TypeScript。对于有静态类型语言像 Java 或 .NET 使用经验的开发者来说要比 JavaScript 更好理解，但对纯 JavaScript 开发者而言，可能需要付出一些努力。</p>\n<p>框架背身就有很多主题需要学习，从基础的开始像模块、依赖注入、装饰器、组件、服务、管道、模板和指令，到高级主题像变化侦测、区块、AoT编译和 RxJS。这些此<a href=\"https://angular.io/docs/ts/latest/quickstart.html\" target=\"_blank\" rel=\"external\">文档</a>中都可以找到。RxJS 本身就是很繁重的主题，在<a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"external\">官方网站</a>上有更多的描述。虽然从基础水平上使用它比较容易，但要使用高级主题会十分的复杂。</p>\n<p>总而言之，我们注意到使用 Angular 要比 React 难得多。眼花缭乱的新概念对新手来讲十分的困惑。即使你已经入门了，你也需要时刻注意像 RxJS 订阅管理，变化侦测性能和<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\" target=\"_blank\" rel=\"external\">未知的东西</a>（是的，这是来自文档实际建议）。我们会经常遇到难以理解的错误信息，所以不得不经常检索它们并祈求得到一个精准的匹配。</p>\n<p>这看起来好像我们更倾向于 React，的确是。结合我们利用同样大小和复杂度的 Angular 和 React 项目，对新手开发者进行培训的经验，React 更加的顺滑。但是，像我之前所说的，这取决于多种因素，可能对你来说会有所不同。</p>\n<h2 id=\"契合度\"><a href=\"#契合度\" class=\"headerlink\" title=\"契合度\"></a>契合度</h2><p>你可能已经注意到每个框架都有它本身一系列的功能，有好的也有坏的。但在特定环境外的分析已经完成并且没能在选择哪个框架上给出答案。为了做出决定，你不得不从你自己项目的角度来考查它。这些事情需要你自己来做。</p>\n<p>现在，结合你的项目试着回答下面这些问题，顺便想想是否符合关于这两个框架你已经学到的特性。列表可能还不完全，但是应该够开始讨论了：</p>\n<ol>\n<li>项目有多大？</li>\n<li>要维护多久？</li>\n<li>所有的功能都被提前定义好还是你希望灵活一些？</li>\n<li>如果所有的特性已经明确，你需要什么功能？</li>\n<li>应用场景和业务逻辑是否复杂？</li>\n<li>针对哪些平台？Web端，移动端，桌面端？</li>\n<li>是否需要服务端渲染？ SEO 重要么？</li>\n<li>是否需要处理许多实时事件流？</li>\n<li>你的团队有多大？</li>\n<li>开发者的经验和他们的知识背景如何？</li>\n<li>是否有一些你想用的现成组件库？</li>\n</ol>\n<p>如果你打算启动一个大项目，你可能想最小化做出不当选择的风险，首先考虑做一个概念性的验证产品。使用框架，通过简单方式，试着实现项目的一些关键特性。这通常不会花费你太多的时间，但会给你一些有价值的经验来验证关键技术需求。如果你对结果满意，你可以继续进行完整的开发。如果不满意，从长远来看其实节省了你的时间。</p>\n<h2 id=\"一招绝？\"><a href=\"#一招绝？\" class=\"headerlink\" title=\"一招绝？\"></a>一招绝？</h2><p>一旦你为你的项目选择了一个框架，你将会在接下来的项目中忍不住的想用同样的技术栈。不要这样。虽然保持技术栈统一是一个不错的注意，但不要总是使用同样的方法。每一个项目开始之前，花点时间再回答一遍上面的问题。可能对下个项目而言，答案就不一样了。另外，如果你想用不熟悉的技术栈做一个小项目，做吧。这些经历会带给你宝贵的经验。开放你的思维，并且从错误中不断学习。在某一点，一项特定的技术会让你自然而然的觉得正确。</p>\n<p><em>此文由同行 <a href=\"https://www.sitepoint.com/author/mbrown/\" target=\"_blank\" rel=\"external\">Jurgen Van de Moere</a> 和 <a href=\"https://www.sitepoint.com/author/jvandemoere/\" target=\"_blank\" rel=\"external\">Joan Yin</a> 校对. 谢谢 SitePoint 所有的校对人员，你们让 SitePoint 的内容更加的优秀!</em></p>\n<h3 id=\"作者的更多文章\"><a href=\"#作者的更多文章\" class=\"headerlink\" title=\"作者的更多文章\"></a>作者的更多文章</h3><ul>\n<li><a href=\"https://www.sitepoint.com/automated-accessibility-checking-with-axe/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">Automated Accessibility Checking with aXe</a></li>\n<li><a href=\"https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">React Storybook: Develop Beautiful User Interfaces with Ease</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://p0.qhimg.com/t01f5158142a5d7c41c.png\" alt=\"Two knights jousting, with React and Angular logos on their shields\"></p>\n<p><em>译者水平有限，原汁原味请移步：<a href=\"https://www.sitepoint.com/react-vs-angular/\" target=\"_blank\" rel=\"external\">原文链接</a></em></p>\n<p>应该选择 Angular 还是 React？现在JS框架两强的格局让许多开发者选择起来很纠结。无论你是一个正在思考如何入门的新手，还是一个为下个项目挑选框架的设计者，或是一个架构师为公司做长远的规划，你都有可能从学习这个主题中受益。</p>\n<p>为了节省你的时间，提前做出如下声明：在哪个框架更好这个问题上，本文不会给你一个明确的答案。但是，不想其他类似主题的文章。我不能告诉你答案，是因为一项特定的技术是否适合你的开发环境和使用场景取决于多种因素。</p>\n<p>由于不能直接回答这个问题，我们会尝试从其他的方面进行解释。我们将会通过对比 Angular（2+，不是老版本的AngularJS）和 React 来演示在两个类型相似的框架中，如何选择并调试适合自己环境的框架。你知道的，“授人以鱼不如授人以渔”。这样在以后，当这两者被更好的框架取代的时候，你能再次用同样的思路做出最优的选择。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>在选择任何工具之前，你都需要回答两个简单的问题：“它本身是好的工具吗？”，“它是否适合我的使用场景？”他们本身没有什么意义，所以你需要把这两个问题时刻放在脑海中。好吧，问题可能不是那么的简单，所以，我们尝试把他们分解成一些小的问题。</p>\n<p>工具本身的问题：</p>\n<ul>\n<li>它的成熟度如何以及背后支持它的是谁？</li>\n<li>它有什么样的特性？</li>\n<li>它使用什么样的架构，开发范式，和模式？</li>\n<li>围绕它的生态圈怎么样？</li>\n</ul>\n<p>自我反思的问题：</p>\n<ul>\n<li>我和我的同事能否轻松的学会如何使用它？</li>\n<li>它适合我的项目吗？</li>\n<li>它的开发体验怎么样？</li>\n</ul>\n<p>用这一系列问题，你可以评估任何工具，而我们将以 Angular 和 React 为基础进行比较。</p>\n<p>还有另外一件事我们需要说明。严格来说，拿 Angular 比较 React 不是完全公平的，因为 Angular 是一个成熟、功能完备的框架，而 React 只是一个 UI 组件库。为了弥补差距，我们谈论 React 的时候，包含了一些它经常使用的库。</p>\n<h2 id=\"完备性\"><a href=\"#完备性\" class=\"headerlink\" title=\"完备性\"></a>完备性</h2><p>作为一个熟练开发者的主要能力就是能够在旧技术和前沿技术之间保持平衡。惯例是，当采用还未成熟的新工具时，应注意一些风险：</p>\n<ul>\n<li>工具可能有缺陷并且不稳定</li>\n<li>它可能会被供应商意外的抛弃</li>\n<li>假设你需要帮助，可能没有一个大型的知识库或者成熟的社区</li>\n</ul>\n<p>React 和 Angular 都有良好的出身，所以从这方面来看，我们是没必要担心的。</p>\n<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><p>React 是由 Facebook 开发并维护的，并且用在了他们自己的产品线上， <a href=\"https://github.com/facebook/react/wiki/sites-using-react\" target=\"_blank\" rel=\"external\">包括 Instagram 和 WhatsApp</a>. 它已经出现大约 <a href=\"https://facebook.github.io/react/blog/2013/06/05/why-react.html\" target=\"_blank\" rel=\"external\">3年半</a> 了， 所以它已经不算新了。它也是Github上<a href=\"https://github.com/search?q=stars:%3E1&amp;s=stars&amp;type=Repositories\" target=\"_blank\" rel=\"external\">最流行的库之一</a> ，在撰写本文的时候，它大约有60,000多个 star。听起来不错。</p>\n<h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular（2及以上）出现的比 React 晚一点，但是如果算上之前的版本 AngularJS，情况就反过来了。它主要由 Google 维护并且用在<a href=\"http://angularjs.blogspot.com/2015/11/how-google-uses-angular-2-with-dart.html\" target=\"_blank\" rel=\"external\">AdWords 和 Google Fiber</a> 产品上，很明显他们对此很有信心，显然它不会短时间内消失。</p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><p>像前文提到的，Angular 比 React 多些开箱即用的特性。这是有两面性的，取决于你看待它的角度。<br>两者的核心功能是相似的：组件，数据绑定和平台无关的渲染</p>\n<h3 id=\"Angular-1\"><a href=\"#Angular-1\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 提供了很多现代 web 应用所需的开箱即用的特性。一些标准特性是：</p>\n<ul>\n<li>依赖注入</li>\n<li>以 HTML 的扩展版本为基础实现模板</li>\n<li>由 @angular/router 提供路由功能</li>\n<li>利用 @angular/http 实现 Ajax 请求</li>\n<li>利用 @angular/forms 创建表单</li>\n<li>CSS 组件化</li>\n<li>XSS 防御</li>\n<li>单元测试组件</li>\n</ul>\n<p>当你自己不想花费时间去挑选类库的时候，有这么多开箱即用的特性是很方便的。 而这也意味着你被它们束缚在了一起，即使你不需要它们。并且，通常替换它们需要付出更多的努力。例如，考虑到依赖注入可以用引入来替代，我们相信使用它的小的项目相对于收益会付出更多的开销。</p>\n<h3 id=\"React-1\"><a href=\"#React-1\" class=\"headerlink\" title=\"React\"></a>React</h3><p>使用 React，你的入门更加简单。如果我们只看 React，那么只有：</p>\n<ul>\n<li>无依赖注入</li>\n<li>JSX模板，通过 JavaScript 实现的类 XML 语言</li>\n<li>XSS 防御</li>\n<li>单元测试组件</li>\n</ul>\n<p>特性不多，未必不是好事。这意味着根据需求选择第三方类库的时候，你有更多的自由度。不好的是你不得不自己做出选择。经常与 React 一起使用的流行类库有：</p>\n<ul>\n<li>路由 <a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"external\">React-router</a></li>\n<li>HTTP请求 <a href=\"https://developer.mozilla.org/en/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"external\">Fetch</a> (or <a href=\"https://github.com/mzabriskie/axios\" target=\"_blank\" rel=\"external\">axios</a>)</li>\n<li>CSS 封装 <a href=\"https://github.com/MicheleBertoli/css-in-js\" target=\"_blank\" rel=\"external\">wide variety of techniques</a></li>\n<li>额外的单元测试工具 <a href=\"https://github.com/airbnb/enzyme\" target=\"_blank\" rel=\"external\">Enzyme</a></li>\n</ul>\n<p>我们拥有了选择类库时的自由。这让我们可以根据每个项目的特定需求来调整我们的技术栈，并且不会产生很高的学习成本。</p>\n<h2 id=\"语言、范式和模式\"><a href=\"#语言、范式和模式\" class=\"headerlink\" title=\"语言、范式和模式\"></a>语言、范式和模式</h2><p>回顾一下两个框架的特性，让我来看一下有哪些流行的高级概念。</p>\n<h3 id=\"React-2\"><a href=\"#React-2\" class=\"headerlink\" title=\"React\"></a>React</h3><p>当研究 React 的时候，有一些重要的概念涌上心头：JSX，Flow，Redux</p>\n<h4 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h4><p>许多开发者对 <a href=\"https://facebook.github.io/react/docs/introducing-jsx.html\" target=\"_blank\" rel=\"external\">JSX</a> 持不同的看法：有的人喜欢它，有的人认为这是技术的巨大退步。不是遵循内容与逻辑分离的传统方法，React 决定用一种类 XML 语言把两者组合在一起放到组件中，这样你可以在 JavaScript 代码中直接编写内容标记。</p>\n<p>虽然关于标记和逻辑混合写法这个话题是有争议的，但是它有一个明显的优势：静态分析。如果你的 JSX 标记中有错误，编译器不会保持沉默，它会报出这个错误。这能帮助我们立即发现拼写错误和其他一些愚蠢的错误。</p>\n<h4 id=\"Flow\"><a href=\"#Flow\" class=\"headerlink\" title=\"Flow\"></a>Flow</h4><p><a href=\"https://flow.org/\" target=\"_blank\" rel=\"external\">Flow</a>也是由 Facebook 开发的一款 JavaScript 的类型检查工具。它能解析代码并检查一些常规的类型错误，像隐式转换或空引用。</p>\n<p>不像有着相似目的的 TypeScript，它不需要你迁移到一个新语言并且通过注释你的代码来进行类型检查。对 Flow 来说，类型注释是可选的，可以当做分析器的额外提示。如果你想用静态代码分析，但又不想重写已有的代码，对此而言 Flow 是一个不错的选择。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/writing-better-javascript-with-flow/\" target=\"_blank\" rel=\"external\">Writing Better JavaScript with Flow</a>]</p>\n<h4 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h4><p><a href=\"http://redux.js.org/\" target=\"_blank\" rel=\"external\">Redux</a> 是一个清晰的管理状态变化的类库。它受 <a href=\"http://facebook.github.io/flux/\" target=\"_blank\" rel=\"external\">Flux</a> 的启发，但是做了一些简化。Redux 的核心思想是用单个对象来代表应用的整个状态，该对象被叫做 reducers，通过函数实现。reducers 是纯函数，通过组件分别实现。这能更好的做到关注点与测试分离。</p>\n<p>如果你正在做一个简单的项目，引入 Redux 可能会更加复杂，但是对中大型项目来说，它是一个很好的选择。这个类库变得非常流行，也可以用在 Angular 项目中实现。</p>\n<p>所有的三项特性可以显著的增强你的开发体验：JSX 和 Flow 允许你快速的定位潜在错误，Redux 帮助你搭建一个整洁的项目架构。</p>\n<h3 id=\"Angular-2\"><a href=\"#Angular-2\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 也有一些有趣的东西，叫 TypeScript 和 RxJS。</p>\n<h4 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h4><p><a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"external\">TypeScript</a> 是一门在 JavaScript 基础上，由微软开发的新语言。他是 ES2015 的超集，并且包含了JS语言即将到来的新版本的一些特性。你能用它替代 Babel 来编写最新的 JavaScript。它也提供了一个极其强大的类型检查系统，能够通过注释和类型推理静态分析你的代码。</p>\n<p>还有一个相当微妙的优势。TypeScript 受 Java 和 .NET 的影响很深，所以如果开发者有那些语言背景，他们会发现 TypeScript 比原生 JavaScript 学起来更轻松（注意我们如何根据个人情况选择工具）。虽然 Angular 是第一个采用 TypeScript 的主要框架，但它和 React 用在一起，也是可行的。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/introduction-to-typescript/\" target=\"_blank\" rel=\"external\">An Introduction to TypeScript: Static Typing for the Web</a>]</p>\n<h4 id=\"RxJS\"><a href=\"#RxJS\" class=\"headerlink\" title=\"RxJS\"></a>RxJS</h4><p><a href=\"http://reactivex.io/rxjs/\" target=\"_blank\" rel=\"external\">RxJS</a> 是一个响应式的编程类库，允许对异步的操作和事件做更加灵活的处理。它是利用函数式编程把观察者模式和迭代器模式混合的组合体。RxJS 允许你把一切都当做是一个连续的流值，并且在此之上实现各种各样的操作，像映射，过滤，拆分或合并。</p>\n<p>该类库被 Angular 的 HTTP 模块采用，也在一些内部使用。当你执行一个 HTTP 请求，它返回一个 Observable 替代通常的 Promise。虽然这个库极其强大，但它也相当的复杂。想要精通它，你需要知道不同类型的 “观察者”，“主题” ，以及<a href=\"http://reactivex.io/rxjs/manual/overview.html#operators\" target=\"_blank\" rel=\"external\">上百种方法和操作符</a>。呀，这看起来只是执行 HTTP 请求的一点小工作。</p>\n<p>当需要很多连续的数据流方面的工作的时候，比如 web sockets，在这种情况下 RxJS 是十分有用的，然而，这看起来仍然很复杂。无论如何，当使用 Angular 的时，你至少要对此要有基本的了解。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/functional-reactive-programming-rxjs/\" target=\"_blank\" rel=\"external\">Introduction to Functional Reactive Programming with RxJS</a>]</p>\n<p>我们发现在提高项目的可维护性上，TypeScript 是一个强大的工具，尤其是那些代码量巨大或业务逻辑十分复杂的项目。用 TypeScript 写的代码更容易阅读与跟进。虽然 Angular 已经采用了 TypeScript，我们仍然希望更多的项目使用它。RxJS，换句话说，看起来只在特定情况下有用并且要小心使用。否则，它能给你的项目带去难以想象的复杂度。</p>\n<h2 id=\"生态圈\"><a href=\"#生态圈\" class=\"headerlink\" title=\"生态圈\"></a>生态圈</h2><p>关于开源框架很重要的事情是围绕它而衍生出的工具数量。有时候，那些工具甚至比框架本身更有用。我们来看一下这两个框架最流行的工具和类库。</p>\n<h3 id=\"Angular-3\"><a href=\"#Angular-3\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><h4 id=\"Angular-命令行工具\"><a href=\"#Angular-命令行工具\" class=\"headerlink\" title=\"Angular 命令行工具\"></a>Angular 命令行工具</h4><p>现代框架的流行趋势是通过一个命令行工具来帮助初始化项目，而不必亲自配置。Angular 的工具叫 <a href=\"https://cli.angular.io/\" target=\"_blank\" rel=\"external\">Angular CLI</a>。它允许通过一系列的命令来生成和启动项目。所有与创建应用，启开发环境，跑测试有关的脚本都被巧妙的隐藏在叫 <code>node_modules</code> 的文件夹中。你也能在开发期间通过它生成新的代码。这使得创建新项目十分的简单。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/ultimate-angular-cli-reference/\" target=\"_blank\" rel=\"external\">The Ultimate Angular CLI Reference</a>]</p>\n<h4 id=\"Ionic-2\"><a href=\"#Ionic-2\" class=\"headerlink\" title=\"Ionic 2\"></a>Ionic 2</h4><p><a href=\"http://ionic.io/2\" target=\"_blank\" rel=\"external\">Ionic 2</a> 是一款用来开发移动端混合应用的流行框架的新版本。它提供了一个完美集成了 Angular 2 的 Cordova 容器，和一个漂亮的组件库。通过它，可以轻松的创建移动端应用。如果相比原生应用更倾向于混合应用，那么它将是一个不错的选择。</p>\n<h4 id=\"Material-design-组件\"><a href=\"#Material-design-组件\" class=\"headerlink\" title=\"Material design 组件\"></a>Material design 组件</h4><p>如果你钟爱于 material design，你可能很高兴听到 <a href=\"https://material.angular.io/\" target=\"_blank\" rel=\"external\">Material 组件库</a>可以用于 Angular。虽然当前得到了诸多支持，但其仍然处于早期阶段并且有点简陋，所以，我们希望不久的将来能有所改善。</p>\n<h4 id=\"Angular-universal\"><a href=\"#Angular-universal\" class=\"headerlink\" title=\"Angular universal\"></a>Angular universal</h4><p><a href=\"https://github.com/angular/universal\" target=\"_blank\" rel=\"external\">Angular universal</a> 是一个种子项目，被用来创建支持服务端渲染的项目。</p>\n<h4 id=\"ngrx-store\"><a href=\"#ngrx-store\" class=\"headerlink\" title=\"@ngrx/store\"></a>@ngrx/store</h4><p><a href=\"https://github.com/ngrx/store\" target=\"_blank\" rel=\"external\">@ngrx/store</a> 是受 Redux 启发，利用 pure reducers 基于状态突变，用于 Angular 状态管理的类库。通过集成 RxJS，可以利用变化侦测策略达到更好的性能。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/managing-state-angular-2-ngrx/\" target=\"_blank\" rel=\"external\">Managing State in Angular 2 Apps with ngrx/store</a>]</p>\n<blockquote>\n<p>这里有更多的类库与工具 <a href=\"https://github.com/AngularClass/awesome-angular\" target=\"_blank\" rel=\"external\">the Awesome Angular list</a>.</p>\n</blockquote>\n<h3 id=\"React-3\"><a href=\"#React-3\" class=\"headerlink\" title=\"React\"></a>React</h3><h4 id=\"Create-react-app\"><a href=\"#Create-react-app\" class=\"headerlink\" title=\"Create react app\"></a>Create react app</h4><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"external\">Create-react-app</a> 是用于快速创建 React 项目的命令行工具。跟 Angular CLI 相似，它允许生成一个新项目，启动开发服务和打包。它用 <a href=\"https://www.sitepoint.com/test-react-components-jest/\" target=\"_blank\" rel=\"external\">Jest</a> 做单元测试，一款来自于 Facebook 的比较新的测试工具，本身有一些好的特性。它也支持通过环境变量做灵活的应用分析，本地环境的后端代理，Flow，和其他特性。更多内容请查看 <a href=\"https://www.sitepoint.com/create-react-app/\" target=\"_blank\" rel=\"external\">introduction to create-react-app</a></p>\n<h4 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h4><p><a href=\"https://facebook.github.io/react-native/\" target=\"_blank\" rel=\"external\">React Native</a> 是由 Facebook 开发的，用 React 编写移动端原生应用的平台。不像提供混合应用的 Ionic，React Native 提供真正的原生界面。它提供了一套用于绑定原生控件的标准 React 组件。也允许使用Objective-C，Java 或 Swift等原生代码编写的组件绑定到它们上。</p>\n<h4 id=\"Material-UI\"><a href=\"#Material-UI\" class=\"headerlink\" title=\"Material UI\"></a>Material UI</h4><p>同样，这是用于 React 的 <a href=\"http://www.material-ui.com\" target=\"_blank\" rel=\"external\">material design 组件库</a>。跟 Angular 的版本相比，这个更加成熟并且已经有很多可用的组件。</p>\n<h4 id=\"Next-js\"><a href=\"#Next-js\" class=\"headerlink\" title=\"Next.js\"></a>Next.js</h4><p><a href=\"https://github.com/zeit/next.js/\" target=\"_blank\" rel=\"external\">Next.js</a> 是用于 React 应用在服务端渲染的框架。它提供了一个灵活的方式在服务端全部或部分渲染应用，返回结果给客户端并继续保持在浏览器中。它尝试完成一项复杂的任务，尽可能简单的创建一个通用应用，所以设置也被设计的尽可能简单。</p>\n<h4 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h4><p><a href=\"https://github.com/mobxjs/mobx\" target=\"_blank\" rel=\"external\">MobX</a> 是一个管理应用状态的可选库。代替在一个单一稳定的仓库中保存状态，就像 Redux 所做的，它鼓励你尽量存储所必须的最小状态并且推导出剩下的。它提供了一套修饰符来定义可见性和观察者和介绍状态的逻辑变化。</p>\n<p>[<strong>扩展阅读</strong>: <a href=\"https://www.sitepoint.com/manage-javascript-application-state-mobx/\" target=\"_blank\" rel=\"external\">How to Manage Your JavaScript Application State with MobX</a>]</p>\n<h4 id=\"Storybook\"><a href=\"#Storybook\" class=\"headerlink\" title=\"Storybook\"></a>Storybook</h4><p><a href=\"https://getstorybook.io/\" target=\"_blank\" rel=\"external\">Storybook</a> 是 React 的组件开发环境。它允许快速的创建单个应用来展示你的组件。在此基础上，它还提供了许多组件来记录，开发，测试和设计你的组件。在应用的其他部分，我们发现它在独立开发组件上是极其有用的。在上一篇文章中，你能学到 <a href=\"https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/\" target=\"_blank\" rel=\"external\">关于 Storybook 的更多知识</a>。</p>\n<blockquote>\n<p>这里有更多的类库与工具 <a href=\"https://github.com/enaqx/awesome-react\" target=\"_blank\" rel=\"external\">the Awesome React list</a>.</p>\n</blockquote>\n<h2 id=\"接受度，学习曲线和开发体验\"><a href=\"#接受度，学习曲线和开发体验\" class=\"headerlink\" title=\"接受度，学习曲线和开发体验\"></a>接受度，学习曲线和开发体验</h2><p>选择一项新技术的重要标准就是学习它有多么的容易。当然，答案取决于很多因素，比如你之前的经验，熟悉相关的概念和模式。不管怎样，给定一个框架我们仍然能评估必须学习的新东西的数量。现在，我们假设你已经了解 ES6+，构建工具和所有的这些，让我们看看你还必须要理解什么。</p>\n<h3 id=\"React-4\"><a href=\"#React-4\" class=\"headerlink\" title=\"React\"></a>React</h3><p>使用 React 遇到的第一个障碍就是 JSX。对有些开发者而言，它写起来颇为棘手，然而，它并没有增加太多的复杂性；就像真正的  JavaScript 表达式，和特殊的类 HTML 语法。你也需要学习如何编写组件，用属性来配置和管理内部状态。你不需要学习任何新的逻辑结构与循环，因为所有的这些都是原生 JavaScript。</p>\n<p><a href=\"https://facebook.github.io/react/docs/hello-world.html\" target=\"_blank\" rel=\"external\">官方教程</a>是入门 React 的优秀资源。一旦你完成了它，那么<a href=\"https://reacttraining.com/react-router/web/guides/quick-start\" target=\"_blank\" rel=\"external\">开始熟悉路由</a>。React 路由 v4 版本可能有一些复杂和特别，但无需担心。使用 Redux 需要转变范式，学会利用类库建议的方式完成已经熟悉的任务。免费视频教程 <a href=\"https://egghead.io/courses/getting-started-with-redux\" target=\"_blank\" rel=\"external\">Getting Started with Redux</a> 能够帮助你快速熟悉一些核心概念。根据项目的大小和复杂度你可能不得不寻找和学习一些额外的类库，这可能是比较棘手的部分，但在这之后，一切都会顺风顺水。</p>\n<p>我们很惊喜入门 React 是如此的简单。甚至有后端经验和前端经验有限的人都能快速上手。有完善清晰的错误提示，并且提供了如何解决潜在问题的解释说明。最难的部分可能就是为所需功能寻找合适的类库，但构建和开发一个应用真的十分简单。</p>\n<h3 id=\"Angular-4\"><a href=\"#Angular-4\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>学习 Angular 需要比 React 了解更多的概念。首先，你需要熟悉 TypeScript。对于有静态类型语言像 Java 或 .NET 使用经验的开发者来说要比 JavaScript 更好理解，但对纯 JavaScript 开发者而言，可能需要付出一些努力。</p>\n<p>框架背身就有很多主题需要学习，从基础的开始像模块、依赖注入、装饰器、组件、服务、管道、模板和指令，到高级主题像变化侦测、区块、AoT编译和 RxJS。这些此<a href=\"https://angular.io/docs/ts/latest/quickstart.html\" target=\"_blank\" rel=\"external\">文档</a>中都可以找到。RxJS 本身就是很繁重的主题，在<a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"external\">官方网站</a>上有更多的描述。虽然从基础水平上使用它比较容易，但要使用高级主题会十分的复杂。</p>\n<p>总而言之，我们注意到使用 Angular 要比 React 难得多。眼花缭乱的新概念对新手来讲十分的困惑。即使你已经入门了，你也需要时刻注意像 RxJS 订阅管理，变化侦测性能和<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\" target=\"_blank\" rel=\"external\">未知的东西</a>（是的，这是来自文档实际建议）。我们会经常遇到难以理解的错误信息，所以不得不经常检索它们并祈求得到一个精准的匹配。</p>\n<p>这看起来好像我们更倾向于 React，的确是。结合我们利用同样大小和复杂度的 Angular 和 React 项目，对新手开发者进行培训的经验，React 更加的顺滑。但是，像我之前所说的，这取决于多种因素，可能对你来说会有所不同。</p>\n<h2 id=\"契合度\"><a href=\"#契合度\" class=\"headerlink\" title=\"契合度\"></a>契合度</h2><p>你可能已经注意到每个框架都有它本身一系列的功能，有好的也有坏的。但在特定环境外的分析已经完成并且没能在选择哪个框架上给出答案。为了做出决定，你不得不从你自己项目的角度来考查它。这些事情需要你自己来做。</p>\n<p>现在，结合你的项目试着回答下面这些问题，顺便想想是否符合关于这两个框架你已经学到的特性。列表可能还不完全，但是应该够开始讨论了：</p>\n<ol>\n<li>项目有多大？</li>\n<li>要维护多久？</li>\n<li>所有的功能都被提前定义好还是你希望灵活一些？</li>\n<li>如果所有的特性已经明确，你需要什么功能？</li>\n<li>应用场景和业务逻辑是否复杂？</li>\n<li>针对哪些平台？Web端，移动端，桌面端？</li>\n<li>是否需要服务端渲染？ SEO 重要么？</li>\n<li>是否需要处理许多实时事件流？</li>\n<li>你的团队有多大？</li>\n<li>开发者的经验和他们的知识背景如何？</li>\n<li>是否有一些你想用的现成组件库？</li>\n</ol>\n<p>如果你打算启动一个大项目，你可能想最小化做出不当选择的风险，首先考虑做一个概念性的验证产品。使用框架，通过简单方式，试着实现项目的一些关键特性。这通常不会花费你太多的时间，但会给你一些有价值的经验来验证关键技术需求。如果你对结果满意，你可以继续进行完整的开发。如果不满意，从长远来看其实节省了你的时间。</p>\n<h2 id=\"一招绝？\"><a href=\"#一招绝？\" class=\"headerlink\" title=\"一招绝？\"></a>一招绝？</h2><p>一旦你为你的项目选择了一个框架，你将会在接下来的项目中忍不住的想用同样的技术栈。不要这样。虽然保持技术栈统一是一个不错的注意，但不要总是使用同样的方法。每一个项目开始之前，花点时间再回答一遍上面的问题。可能对下个项目而言，答案就不一样了。另外，如果你想用不熟悉的技术栈做一个小项目，做吧。这些经历会带给你宝贵的经验。开放你的思维，并且从错误中不断学习。在某一点，一项特定的技术会让你自然而然的觉得正确。</p>\n<p><em>此文由同行 <a href=\"https://www.sitepoint.com/author/mbrown/\" target=\"_blank\" rel=\"external\">Jurgen Van de Moere</a> 和 <a href=\"https://www.sitepoint.com/author/jvandemoere/\" target=\"_blank\" rel=\"external\">Joan Yin</a> 校对. 谢谢 SitePoint 所有的校对人员，你们让 SitePoint 的内容更加的优秀!</em></p>\n<h3 id=\"作者的更多文章\"><a href=\"#作者的更多文章\" class=\"headerlink\" title=\"作者的更多文章\"></a>作者的更多文章</h3><ul>\n<li><a href=\"https://www.sitepoint.com/automated-accessibility-checking-with-axe/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">Automated Accessibility Checking with aXe</a></li>\n<li><a href=\"https://www.sitepoint.com/react-storybook-develop-beautiful-user-interfaces-with-ease/?utm_source=sitepoint&amp;utm_medium=relatedinline&amp;utm_term=&amp;utm_campaign=relatedauthor\" target=\"_blank\" rel=\"external\">React Storybook: Develop Beautiful User Interfaces with Ease</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj4cl7dhe000098vkn4ww8wjd","tag_id":"cj4cl7dhi000198vk357r6yck","_id":"cj4cl7dhk000398vkwxozr3h8"},{"post_id":"cj4cl7dhe000098vkn4ww8wjd","tag_id":"cj4cl7dhj000298vk0vlc9in2","_id":"cj4cl7dhk000498vkt32ashmy"},{"post_id":"cj4cl7dhl000598vkyln006rg","tag_id":"cj4cl7dhn000798vk8zrtq8tg","_id":"cj4cl7dhr000a98vkguerfm6v"},{"post_id":"cj4cl7dhl000598vkyln006rg","tag_id":"cj4cl7dhj000298vk0vlc9in2","_id":"cj4cl7dhr000b98vkmgugil3i"},{"post_id":"cj4cl7dhm000698vkd3h9y2xj","tag_id":"cj4cl7dhn000798vk8zrtq8tg","_id":"cj4cl7dhs000d98vkz7hbtnuv"},{"post_id":"cj4cl7dhm000698vkd3h9y2xj","tag_id":"cj4cl7dhj000298vk0vlc9in2","_id":"cj4cl7dhs000e98vkqpb9czo4"},{"post_id":"cj4cl7dhn000898vkq4qat55v","tag_id":"cj4cl7dhn000798vk8zrtq8tg","_id":"cj4cl7dht000f98vkcgpa2djw"},{"post_id":"cj4cl7dhn000898vkq4qat55v","tag_id":"cj4cl7dhj000298vk0vlc9in2","_id":"cj4cl7dht000g98vkfyxs9a12"},{"post_id":"cj4cl7dhw000h98vk3zkg9pmq","tag_id":"cj4cl7dhn000798vk8zrtq8tg","_id":"cj4cl7dhx000i98vk89oj5sis"},{"post_id":"cj4cl7dhw000h98vk3zkg9pmq","tag_id":"cj4cl7dhj000298vk0vlc9in2","_id":"cj4cl7dhx000j98vk64e8y7rs"}],"Tag":[{"name":"CSS","_id":"cj4cl7dhi000198vk357r6yck"},{"name":"翻译","_id":"cj4cl7dhj000298vk0vlc9in2"},{"name":"JavaScript","_id":"cj4cl7dhn000798vk8zrtq8tg"}]}}