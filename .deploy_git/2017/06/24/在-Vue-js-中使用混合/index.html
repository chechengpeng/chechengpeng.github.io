<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>在 Vue.js 中使用混合 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="_译者水平有限，原汁原味请移步：原文链接_ 有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。 这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快">
<meta name="keywords" content="JavaScript,翻译">
<meta property="og:type" content="article">
<meta property="og:title" content="在 Vue.js 中使用混合">
<meta property="og:url" content="http://yoursite.com/2017/06/24/在-Vue-js-中使用混合/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="_译者水平有限，原汁原味请移步：原文链接_ 有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。 这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快">
<meta property="og:image" content="http://p0.qhimg.com/t0195da96ce6d7eb510.jpg">
<meta property="og:updated_time" content="2017-06-25T12:43:18.299Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="在 Vue.js 中使用混合">
<meta name="twitter:description" content="_译者水平有限，原汁原味请移步：原文链接_ 有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。 这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快">
<meta name="twitter:image" content="http://p0.qhimg.com/t0195da96ce6d7eb510.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-在-Vue-js-中使用混合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/24/在-Vue-js-中使用混合/" class="article-date">
  <time datetime="2017-06-24T15:22:38.000Z" itemprop="datePublished">2017-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      在 Vue.js 中使用混合
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>_译者水平有限，原汁原味请移步：<a href="https://css-tricks.com/using-mixins-vue-js/?utm_campaign=Revue%20newsletter&amp;utm_medium=Newsletter&amp;utm_source=revue/" target="_blank" rel="external">原文链接</a>_</p>
<p>有一种很常见的情况：有两个非常相似的组件，它们共享同样的基本函数，并且它们之间也有足够的不同，这时你站在了一个十字路口：我是把它拆分成两个不同的组件？还是只使用一个组件，创建足够的属性来改变不同的情况。</p>
<p>这些解决方案都不够完美：如果你拆分成两个组件，你就不得不冒着如果功能变动你要在两个文件中更新它的风险，这违背了 DRY 前提。另一方面，太多的属性会很快会变得混乱不堪，对维护者很不友好，甚至是你自己，为了使用它，需要理解一大段上下文，这会让你感到失望。</p>
<p>使用混合。Vue 中的混合对编写函数式风格的代码很有用，因为函数式编程就是通过减少移动的部分让代码更好理解（引用于 <a href="https://twitter.com/mfeathers/status/29581296216?lang=en" target="_blank" rel="external">Michael Feathers</a> ）。混合允许你封装一块在应用的其他组件中都可以使用的函数。如果被正确的使用，他们不会改变函数作用域外部的任何东西，所以多次执行，只要是同样的输入你总是能得到一样的值。这真的很强大。</p>
<h3 id="基础实例"><a href="#基础实例" class="headerlink" title="基础实例"></a>基础实例</h3><p>我们有一对不同的组件，它们的作用是切换一个状态布尔值，一个模态框和一个提示框。这些提示框和模态框除了在功能上，没有其他共同点：它们看起来不一样，用法不一样，但是逻辑一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 模态框</div><div class="line">const Modal = &#123;</div><div class="line">  template: &apos;#modal&apos;,</div><div class="line">  data() &#123;</div><div class="line">    return &#123;</div><div class="line">      isShowing: false</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    toggleShow() &#123;</div><div class="line">      this.isShowing = !this.isShowing;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    appChild: Child</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 提示框</div><div class="line">const Tooltip = &#123;</div><div class="line">  template: &apos;#tooltip&apos;,</div><div class="line">  data() &#123;</div><div class="line">    return &#123;</div><div class="line">      isShowing: false</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    toggleShow() &#123;</div><div class="line">      this.isShowing = !this.isShowing;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    appChild: Child</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以提取出这个逻辑并创建可以被重用的项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">const toggle = &#123;</div><div class="line">  data() &#123;</div><div class="line">    return &#123;</div><div class="line">      isShowing: false</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    toggleShow() &#123;</div><div class="line">      this.isShowing = !this.isShowing;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const Modal = &#123;</div><div class="line">  template: &apos;#modal&apos;,</div><div class="line">  mixins: [toggle],</div><div class="line">  components: &#123;</div><div class="line">    appChild: Child</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const Tooltip = &#123;</div><div class="line">  template: &apos;#tooltip&apos;,</div><div class="line">  mixins: [toggle],</div><div class="line">  components: &#123;</div><div class="line">    appChild: Child</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>查看 Sarah Drasner(<a href="https://codepen.io/sdras" target="_blank" rel="external">@sdras</a>) 在<a href="https://codepen.io" target="_blank" rel="external">CodePen</a>上编写 <a href="https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/" target="_blank" rel="external">混合</a>的例子</p>
<p>为了更容易理解混合，这个例子故意编写的简单一些。真实应用中使用混合的有，包含但不限于：获取视窗和组件的尺寸，采集特定的鼠标事件和图表的基本元素。Paul Pflugradt 有一个关于 <a href="https://github.com/paulpflug/vue-mixins" target="_blank" rel="external">Vue Mixins 的优秀项目</a>，但值得一提的是它是用 coffeescript 编写的。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>这个例子没有告诉我们在一个真实的应用中如何使用，所以，我们看看接下来要怎么做。</p>
<p>你可以按照你喜欢的任意方式设置你的目录结构，但为了更好的组织结构我喜欢新建一个 <code>mixin</code> 目录。我们创建的这个文件含有<code>.js</code>扩展名（跟<code>.vue</code>相对，就像我们的其他文件），并且为了混合我们需要输出一个对象。</p>
<p><img src="http://p0.qhimg.com/t0195da96ce6d7eb510.jpg" alt="directory structure shows mixins in a folder in components directory"></p>
<p>接着在 Modal.vue 中使用它，通过像下面这样的引入方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import Child from &apos;./Child&apos;</div><div class="line">import &#123; toggle &#125; from &apos;./mixins/toggle&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  name: &apos;modal&apos;,</div><div class="line">  mixins: [toggle],</div><div class="line">  components: &#123;</div><div class="line">    appChild: Child</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使我们使用的是一个对象而不是一个组件，生命周期函数对我们来说仍然是可用的，理解这点很重要。我们可以在这使用<code>mounted()</code>钩子函数，它将被应用于组件的生命周期上，这种工作方式真的很灵活也很强大。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>看最后这个例子，我们可以看到，我们不仅有自己的函数，而且来自于混合的生命周期函数对我们来说也是可用的，所以当在组件上注册重复的过程时，顺序很重要。默认混合上会首先被注册，组件上的接着注册，这样如有必要我们可以重写它。<strong>组件拥有最终发言权</strong>当有一个冲突并且这个组件不得不“决定”哪个胜出的时候，这真的变得很重要，否则，所有的东西都被放在一个数组当中执行，混合中的先执行，组件中的接着执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//mixin</div><div class="line">const hi = &#123;</div><div class="line">  mounted() &#123;</div><div class="line">    console.log(&apos;hello from mixin!&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//vue instance or component</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  mixins: [hi],</div><div class="line">  mounted() &#123;</div><div class="line">    console.log(&apos;hello from Vue instance!&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//Output in console</div><div class="line">&gt; hello from mixin!</div><div class="line">&gt; hello from Vue instance!</div></pre></td></tr></table></figure>
<p>如果这两个冲突了，我们看看 Vue实例或组件是如何取胜的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//mixin</div><div class="line">const hi = &#123;</div><div class="line">  methods: &#123;</div><div class="line">    sayHello: function() &#123;</div><div class="line">      console.log(&apos;hello from mixin!&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  mounted() &#123;</div><div class="line">    this.sayHello()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//vue instance or component</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  mixins: [hi],</div><div class="line">  methods: &#123;</div><div class="line">    sayHello: function() &#123;</div><div class="line">      console.log(&apos;hello from Vue instance!&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  mounted() &#123;</div><div class="line">    this.sayHello()</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// Output in console</div><div class="line">&gt; hello from Vue instance!</div><div class="line">&gt; hello from Vue instance!</div></pre></td></tr></table></figure>
<p>你可能已经注意到这有两个<code>console.log</code>而不是一个——这是因为第一个函数被调用时，没有被销毁，它被重写了。我们两次调用的都是<code>sayHello()</code>函数。</p>
<h3 id="全局混合"><a href="#全局混合" class="headerlink" title="全局混合"></a>全局混合</h3><p>当我们使用全局混合时，我们不是指能够在每个组件上访问它们，就像是过滤器一样。我们能够通过<code>mixins:[toggle]</code>访问组件上的混合对象。</p>
<p>全局混合被注册到了<em>每个单一组件上</em>。因此，它们的使用场景极其有限并且要非常的小心。一个我能想到的用途就是它像一个插件，你需要赋予它访问所有东西的权限。但即使在这种情况下，我也对你正在做的保持警惕，尤其是你在应用中扩展的函数，可能对你来说是不可知的。</p>
<p>为了创建一个全局实例，我们可以把它放在 Vue 实例之上。在一个典型的 Vue-cli 初始化的项目中，它可能在你的<code>main.js</code>文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.mixin(&#123;</div><div class="line">  mounted() &#123;</div><div class="line">    console.log(&apos;hello from mixin!&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>再次提醒，小心使用它！那个 <code>console.log</code>将会出现在每个组件上。这种情况还不算坏（除了控制台上有多余的输出），但如果它被错误的使用，你将能看到它会多么的有害。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>混合对于封装一小段想要复用的代码来讲是有用的。对你来说它们当然不是唯一可行的选择：高阶组件，例如，允许组合相似函数，这只是实现的一种方式。我喜欢混合，因为我不需要传递状态，但是这种模式当然也可能会被滥用，所以，仔细思考哪种选择对你的应用最有意义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/24/在-Vue-js-中使用混合/" data-id="cj4cq6bvr0004e8vksrj5216v" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/25/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/2017/06/19/类的复杂度和函数式编程/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">rext</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/翻译/" style="font-size: 20px;">翻译</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/06/24/在-Vue-js-中使用混合/">在 Vue.js 中使用混合</a>
          </li>
        
          <li>
            <a href="/2017/06/19/类的复杂度和函数式编程/">rext</a>
          </li>
        
          <li>
            <a href="/2017/06/16/深入剖析现代-JavaScript-应用/">深入剖析现代 JavaScript 应用</a>
          </li>
        
          <li>
            <a href="/2017/06/08/CSS-BEM-命名规则核心概念介绍/">CSS BEM 命名规则核心概念介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>